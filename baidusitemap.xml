<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/12/23/hexo-config/</loc>
    <lastmod>2014-12-23T14:31:57.000Z</lastmod>
    <data>
        <display>
        <title>hexo静态博客之配置篇</title>
        <content><![CDATA[<blockquote>
<h5 id="本部分别讲述：hexo配置、主题配置、建议安装的插件">本部分别讲述：hexo配置、主题配置、建议安装的插件</h5>
<h5 id="列出一些我常用的配置及插件">列出一些我常用的配置及插件</h5>
</blockquote>
<h3 id="一、_hexo配置">一、 hexo配置</h3>
<ol>
<li>先来讲 <code>F:\hexo\_config.yml</code>。这个配置文件是hexo的主要配置文件，核心部分。</li>
</ol>
<pre><code><span class="preprocessor">#Site 站点配置</span>
<span class="label">title:</span> 沈吉祥的博客 <span class="preprocessor">#站点名</span>
<span class="label">subtitle:</span> 人生不应该是看得到未来的 <span class="preprocessor">#副标题</span>
<span class="label">description:</span> 沈吉祥的博客,专注于java技术,提供程序源码和技术知识分享的个人博客网站。 <span class="preprocessor">#给搜索引擎看的，对站点的描述，可以自定义</span>
<span class="label">keywords:</span> 云计算,个人博客,java,java博客,hexo,hexo博客,沈吉祥的博客,沈吉祥  <span class="preprocessor">#给搜索引擎看的，站点关键字，可以自定义</span>
<span class="label">author:</span> 沈吉祥 <span class="preprocessor">#站点作者，用不用取决于主题</span>
<span class="label">email:</span> <span class="number">1038342063</span>@qq.com <span class="preprocessor">#邮箱</span>
<span class="label">language:</span> <span class="built_in">zh</span>-CN <span class="preprocessor">#语言，中文</span>

<span class="preprocessor"># URL下面的照写就是了，不需改动</span>
<span class="label">url:</span> http://www.shenjixiang.cn <span class="preprocessor">#创建sitemap.xml需要配置该项，有个人域名就写上</span>
<span class="label">root:</span> / 
<span class="label">permalink:</span> :year/:month/:day/:title/
<span class="label">tag_dir:</span> tags
<span class="label">archive_dir:</span> archives
<span class="label">category_dir:</span> categories

<span class="preprocessor"># Directory</span>
<span class="label">source_dir:</span> source
<span class="label">public_dir:</span> public

<span class="preprocessor"># Writing 不需改动</span>
<span class="label">new_post_name:</span> :title.md <span class="preprocessor"># File name of new posts</span>
<span class="label">default_layout:</span> post
<span class="label">auto_spacing:</span> false <span class="preprocessor"># Add spaces between asian characters and western characters</span>
<span class="label">titlecase:</span> false <span class="preprocessor"># Transform title into titlecase</span>
<span class="label">external_link:</span> true <span class="preprocessor"># Open external links in new tab</span>
<span class="label">max_open_file:</span> <span class="number">100</span>
<span class="label">multi_thread:</span> true
<span class="label">filename_case:</span> <span class="number">0</span>
<span class="label">render_drafts:</span> false
<span class="label">post_asset_folder:</span> false
<span class="label">highlight:</span>
  enable: true
  backtick_code_block: true
  line_number: true
  tab_replace:

<span class="preprocessor"># Category &amp; Tag 不需改动</span>
<span class="label">default_category:</span> uncategorized
<span class="label">category_map:</span>
<span class="label">tag_map:</span>

<span class="preprocessor"># Archives 不需改动</span>
<span class="preprocessor">## 2: Enable pagination</span>
<span class="preprocessor">## 1: Disable pagination</span>
<span class="preprocessor">## 0: Fully Disable</span>
<span class="label">archive:</span> <span class="number">1</span>
<span class="label">category:</span> <span class="number">1</span>
<span class="label">tag:</span> <span class="number">1</span>

<span class="preprocessor"># Server 不需改动</span>
<span class="preprocessor">## Hexo uses Connect as a server</span>
<span class="preprocessor">## You can customize the logger format as defined in</span>
<span class="preprocessor">## http://www.senchalabs.org/connect/logger.html</span>
<span class="label">port:</span> <span class="number">4000</span>
<span class="label">server_ip:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>
<span class="label">logger:</span> false
<span class="label">logger_format:</span>
<span class="preprocessor"># Date / Time format</span>
<span class="preprocessor">## Hexo uses Moment.js to parse and display date</span>
<span class="preprocessor">## You can customize the date format as defined in</span>
<span class="preprocessor">## http://momentjs.com/docs/#/displaying/format/</span>
<span class="label">date_format:</span> MMMDD YYYY
<span class="label">time_format:</span> H:mm:ss

<span class="preprocessor"># Pagination</span>
<span class="preprocessor">## Set per_page to 0 to disable pagination</span>
<span class="label">per_page:</span> <span class="number">12</span> <span class="preprocessor">#设置每页显示条数</span>
<span class="label">pagination_dir:</span> page

<span class="preprocessor"># duoshuo 多说的用户名</span>
<span class="label">duoshuo_shortname:</span> 

<span class="preprocessor"># Extensions 这里配置站点所用主题和插件，暂默认，后面会介绍怎么修改，下面有我用到的插件</span>
<span class="preprocessor">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</span>
<span class="preprocessor">## Themes: https://github.com/tommy351/hexo/wiki/Themes</span>
<span class="label">theme:</span> light <span class="preprocessor">#主题名称配置</span>
<span class="label">exclude_generator:</span>
<span class="label">plugins:</span>
- hexo-generator-sitemap
- hexo-generator-baidu-sitemap
- hexo-generator-feed    
- hexo-generator-alias

<span class="preprocessor">#百度sitemap插件路径配置</span>
<span class="label">baidusitemap:</span>
    path: baidusitemap.xml

<span class="preprocessor">#Deployment 站点部署到github要配置，后面详讲</span>
<span class="label">deploy:</span>
  type: github
  repository: git@github.com:shenjixiang/shenjixiang.github.io.git
  branch: master
</code></pre><h3 id="二、主题配置">二、主题配置</h3>
<pre><code>主题下载地址：http<span class="variable">s:</span>//github.<span class="keyword">com</span>/hexojs/hexo/wiki/Themes
</code></pre><ol>
<li>选择自己喜欢的主题，在hexo博客目录下右键gitbash，输入git clone git@github.com:hustcer/hexo-theme-air.git themes/air下载到本地目录</li>
<li>可到themes目录下看到air这个目录，这里面就是下载的主题。在<code>F:\hexo\_config.yml</code>这个配置文件里theme改为air</li>
<li>主题配置：<code>F:\hexo\themes\_config.yml</code>，这个配置就太多了。因为各种主题的配置及其使用的插件都不一样。</li>
<li>一般都有这几个配置：</li>
</ol>
<pre><code><span class="label">menu:</span> <span class="preprocessor">#站点右上角导航栏，暂时默认，后面介绍修改</span>
  首页: /
  存档: /archives
  关于: /about      
<span class="label">widgets:</span> <span class="preprocessor">#站点右边栏，暂时默认，后面介绍修改和添加</span>
- search
- category
- tagcloud
- weibo
- blogroll

<span class="label">excerpt_link:</span> 阅读全文 <span class="preprocessor">#替换为中文</span>

<span class="label">plugins:</span> <span class="preprocessor">#插件配置</span>

<span class="label">fancybox:</span> true <span class="preprocessor">#图片效果，默认</span>

<span class="label">rss:</span>  /atom.xml <span class="preprocessor">#生成RSS，需要配置路径，暂时默认，后面介绍</span>
</code></pre><ul>
<li>配置这些多弄几下就熟悉了。挺简单的，呵呵！！</li>
</ul>
<h3 id="三、hexo建议安装的插件">三、hexo建议安装的插件</h3>
<pre><code>插件汇集地址：http<span class="variable">s:</span>//github.<span class="keyword">com</span>/hexojs/hexo/wiki/Plugins
</code></pre><ol>
<li>插件下载完成之后，也需要配置才能使用。在<code>F:\hexo\_config.yml</code>里，像我配置的那样配置，只需插件名即可。</li>
</ol>
<h3 id="四、启动服务器">四、启动服务器</h3>
<ol>
<li>hexo server，访问localhost:4000预览效果。（退出server用Ctrl+C），看看主题效果，不满意再换别的或者自己修改。<h5 id="好啦，今天基本就这些。有问题留言或百度，自己多动动脑筋想想，一般都会解决的。接下来会讲讲写文章和github操作。">好啦，今天基本就这些。有问题留言或百度，自己多动动脑筋想想，一般都会解决的。接下来会讲讲写文章和github操作。</h5>
</li>
</ol>
]]></content>
        <pubTime>2014-12-23T13:19:22.000Z</pubTime>
        
         
              <breadCrumb title="hexo" url="http://www.shenjixiang.cn/tags/hexo/"/>
          
              <breadCrumb title="博客搭建" url="http://www.shenjixiang.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
          
              <breadCrumb title="hexo" url="http://www.shenjixiang.cn/categories/hexo/"/>
          
        </display>
    </data>
    </url>

    
    
  <url>
    <loc>http://www.shenjixiang.cn/2014/12/19/hexo-introduce/</loc>
    <lastmod>2014-12-20T15:05:33.000Z</lastmod>
    <data>
        <display>
        <title>hexo静态博客之介绍篇</title>
        <content><![CDATA[<h5 id="开篇废话">开篇废话</h5>
<ul>
<li>今天同学小聚了一下，因为都是code，说好的不说工作上的事，结果聚到一起都是说的这些。有吐槽的，有讨论公司各种xxx的。觉得在这蓉城都还发展的不错，看来我们班个个都是人才啊。</li>
<li>今天谈到了一问题，几个好朋友想做做网站，交流一下各自的想法。我打算写一下自己建立这个博客的详细过程。有问题都可以留言的，我会及时回复。</li>
<li>后面我都会上传我用到的工具和一些资料到网盘，做到真正的方便使用！！统一到 <a href="/resources">资源共享</a> 下载</li>
</ul>
<h3 id="技术工具功能介绍">技术工具功能介绍</h3>
<ul>
<li>git：用来上传博客代码，管理博客(必须)</li>
<li>github/gitcafe账号：建议用github，虽然速度慢点，但是相对gitcafe稳定。(必须)</li>
<li>nodejs：hexo必须工具(必须)</li>
<li>hexo：真正用到的生成博客静态页面的项目(必须)</li>
<li>个人域名：可以不用，github会提供一个二级域名，但申请一个对收录、排名、seo相对较好(建议)</li>
</ul>
<h3 id="hexo介绍">hexo介绍</h3>
<ul>
<li>基于Node.js的静态博客程序，用于生成静态网页。</li>
<li>相比jekyll、Octopress，它的优点很明显：生成页面速度极快，主题多，用的人群多，版本更新快，插件丰富，只要会点html,js,css都可以轻松更改主题样式，布局等，易维护。</li>
<li>支持markdown，用过的人肯定知道Markdown的强大，能够迅速写出一篇文章，而不用一个个去调样式，布局等等。</li>
<li>生成页面后，执行一个指令即可部署到github或者gitcafe</li>
<li>平时使用中仅需要<code>hexo n post</code>、<code>hexo g</code>、<code>hexo s</code>、<code>hexo d</code>四个命令。</li>
</ul>
<h5 id="那么问题来了，怎样搭建hexo博客？请期待下一篇文章。">那么问题来了，怎样搭建hexo博客？请期待下一篇文章。</h5>
]]></content>
        <pubTime>2014-12-19T15:32:37.000Z</pubTime>
        
         
              <breadCrumb title="hexo" url="http://www.shenjixiang.cn/tags/hexo/"/>
          
              <breadCrumb title="博客搭建" url="http://www.shenjixiang.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
          
              <breadCrumb title="hexo" url="http://www.shenjixiang.cn/categories/hexo/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/12/20/hexo-build/</loc>
    <lastmod>2014-12-20T15:04:47.000Z</lastmod>
    <data>
        <display>
        <title>hexo静态博客之搭建篇</title>
        <content><![CDATA[<h3 id="下载必备工具">下载必备工具</h3>
<ul>
<li><a href="http://git-scm.com/download/" target="_blank" rel="external">下载git</a> (执行即可完成安装)</li>
<li><a href="http://nodejs.org/download/" target="_blank" rel="external">下载nodejs</a>  (执行即可完成安装)</li>
<li>以上安装完成后最好重启电脑</li>
</ul>
<h3 id="安装hexo(利用_npm_命令)">安装hexo(利用 npm 命令)</h3>
<ul>
<li>在E盘建立一个专门存放博客页面的目录。</li>
<li>在博客目录下，鼠标右键选择Git bash</li>
<li>输入命令：<code>npm install -g hexo</code>(如果存在下载慢的情况，可ctrl+c退出，重新键入命令下载即可,多试几次)</li>
<li>输入初始化命令：<code>hexo init</code></li>
<li>完成依赖包安装：<code>npm install</code></li>
</ul>
<h3 id="本地运行博客">本地运行博客</h3>
<ul>
<li>生成博客页面：<code>hexo generate</code></li>
<li>运行：<code>hexo server</code></li>
<li>在浏览器里输入地址：localhost:4000，即可访问</li>
<li>到这里，基本搭建就已成功了，接下来选择安装自己喜欢的主题</li>
</ul>
]]></content>
        <pubTime>2014-12-20T07:10:13.000Z</pubTime>
        
         
              <breadCrumb title="hexo" url="http://www.shenjixiang.cn/tags/hexo/"/>
          
              <breadCrumb title="博客搭建" url="http://www.shenjixiang.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
          
              <breadCrumb title="hexo" url="http://www.shenjixiang.cn/categories/hexo/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/10/28/mysqlMajor/</loc>
    <lastmod>2014-12-20T08:05:07.000Z</lastmod>
    <data>
        <display>
        <title>MySQL海量数据优化策略总结</title>
        <content><![CDATA[<h3 id="优化事项">优化事项</h3>
<ul>
<li><strong>对查询来说，切记避免全表扫描！！！</strong></li>
</ul>
<ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>避免在 where 子句中对字段进行 <codei>null</codei> 值判断，否则将导致引擎放弃使用索引而进行全表扫描，<br> 如：select id from t where num is null<br>　　可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br>　　select id from t where num=0</li>
<li>避免在 where 子句中使用 <codei>!=</codei>、<codei>&lt;&gt; </codei>、<codei>or </codei>、<codei>in </codei>、<codei>not in </codei>、<codei>like</codei>操作符，否则将引擎放弃使用索引而进行全表扫描。<br> 如：select id from t where num=10 or num=20<br>　　可以这样查询：<br>　　select id from t where num=10<br>　　union all<br>　　select id from t where num=20</li>
<li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>　　如：select id from t where substring(name,1,3)=’abc’ —name以abc开头的id　<br>　　应改为:<br>　　select id from t where name like ‘abc%’</li>
<li>不要在 where 子句中的<codei>=</codei>左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
<li>很多时候用 exists 代替 in 是一个好的选择：<br>　　select num from a where num in(select num from b)<br>　　用下面的语句替换：<br>　　select num from a where exists(select 1 from b where num=a.num)</li>
<li><codei>索引并不是越多越好</codei>，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引。一个表的索引数最好不要超过6个。</li>
<li>应尽可能的避免更新 clustered（聚集索引，索引可分聚集和非聚集索引） 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li>
<li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</li>
<li>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</li>
<li>尽量避免大事务操作，提高系统并发能力。</li>
<li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</li>
</ol>
<h3 id="优化方法总结">优化方法总结</h3>
<ol>
<li>使用索引来更快地遍历表。<br>缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：<br>a.有大量重复值、且经常有范围查询( &gt; ,&lt; ，&gt; =,&lt; =)和order by、group by发生的列，可考虑建立群集索引;<br>b.经常同时存取多列，且每列都含有重复值可考虑建立组合索引;<br>c.组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就要做相应的更新工作。</li>
<li>任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</li>
<li>IN、OR子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子句中应该包含索引。</li>
<li>只要能满足你的需求，应尽可能使用更小的数据类型：例如使用MEDIUMINT代替INT</li>
<li>尽量把所有的列设置为NOT NULL，如果你要保存NULL，手动去设置它，而不是把它设为默认值。</li>
<li>尽量少用VARCHAR、TEXT、BLOB类型</li>
<li>如果你的数据只有你所知的少量的几个。最好使用ENUM类型</li>
</ol>
]]></content>
        <pubTime>2014-10-28T13:23:39.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
    
  <url>
    <loc>http://www.shenjixiang.cn/2014/12/11/java-load-mediainfoDll/</loc>
    <lastmod>2014-12-11T14:19:05.000Z</lastmod>
    <data>
        <display>
        <title>java调用mediainfo.dll获取媒体文件信息</title>
        <content><![CDATA[<h3 id="闲聊">闲聊</h3>
<blockquote>
<p>使用这种方式获取媒体文件信息也是无奈之举。之前以为可以用jmf，但是发现jmf只是处理流的传输，负责播放媒体文件的。<br>可以看出java的弱点和不足。做这种很细节，跟底层太相关的东西确实有点难。<br>在网上找了很久，我也折腾了很久，才算找出来方法，跟大家分享。</p>
</blockquote>
<h3 id="使用说明">使用说明</h3>
<ul>
<li>一般通过读取码率算出每次需发送多少字节和隔多久发一次，结合udp来发送。使其到达终端播放。</li>
<li>注意mediainfo.dll要放在项目根目录下，linux下需转换成mediainfo.so文件</li>
<li>代码都可以在资源共享，我的代码中下载</li>
<li>MediaInfo在共享里，东西太多就不写在这里了</li>
</ul>
<h3 id="具体代码">具体代码</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">	MediaInfo MI = <span class="keyword">new</span> MediaInfo();</div><div class="line">	String FileName = <span class="string">"d:/媒体文件.wav"</span>;</div><div class="line">	 <span class="keyword">if</span> (MI.Open(FileName)&gt;<span class="number">0</span>){</div><div class="line">		 System.<span class="keyword">out</span>.println(<span class="string">"文件打开成功"</span>);</div><div class="line">		 String m = MI.Get(MediaInfo.StreamKind.General, <span class="number">0</span>, <span class="string">"OverallBitRate"</span>);</div><div class="line">		 System.<span class="keyword">out</span>.println(<span class="string">"综合码率(音视频结合码率)："</span>+m);</div><div class="line">		 System.<span class="keyword">out</span>.println(<span class="string">"文件所有详细信息："</span>+MI.Inform());</div><div class="line">	 }</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
        <pubTime>2014-12-11T14:00:39.000Z</pubTime>
        
         
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/tags/j2EE/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/12/09/java-load-dll/</loc>
    <lastmod>2014-12-09T13:08:11.000Z</lastmod>
    <data>
        <display>
        <title>java调用dll几种方式总结</title>
        <content><![CDATA[<p>常用的就是jni，jnative(基于jni封装了自己的jar包)<br>注意：java调用dll，必须dll里做了对应的处理。列如：方法名必须为_java_包名_类名_方法名</p>
<h3 id="使用JNI调用dll步骤">使用JNI调用dll步骤</h3>
<ul>
<li>新建一个java项目，将dll文件放入src下</li>
<li>配置改项目环境jre下native目录，指向src</li>
<li>项目jdk一定不要用eclipse自带的，用自己安装的jdk路径</li>
<li>按照dll里的目录顺序新建目录及类</li>
<li>声明跟dll里一样的方法，方法前加native关键字(注意参数类型)</li>
<li>代码静态块里写(不要后缀)：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> {</div><div class="line">	System.loadLibrary(<span class="string">"testDll"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>之后写main方法就可以调用了。如有报错，注意观察报错信息，可能会缺少依赖dll文件</li>
</ul>
<h3 id="简单封装JNI">简单封装JNI</h3>
<ul>
<li>简单封装一个调用dll的类</li>
<li>代码可以在资源共享，我的代码中下载</li>
<li>调用代码(主要是static块代码变了),DllUtil这块代码在共享里下载</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static {</div><div class="line">	try {</div><div class="line">		DllUtil.extractFromJar(<span class="string">"testDll.dll"</span>, <span class="string">"testDll.dll"</span>, System</div><div class="line">				.getProperty(<span class="string">"java.io.tmpdir"</span>));</div><div class="line">		System.load(System.getProperty(<span class="string">"java.io.tmpdir"</span>) + <span class="string">"\\testDll.dll"</span>);</div><div class="line">		System.out.println(<span class="string">"load testDll.dll success!!"</span>);</div><div class="line">	} catch (Exception e) {</div><div class="line">		System.out.println(<span class="string">"testDll.dll error:"</span> + e.getMessage());</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
        <pubTime>2014-12-09T11:59:26.000Z</pubTime>
        
         
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/tags/j2EE/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/11/25/ad-hengchuang/</loc>
    <lastmod>2014-12-06T15:13:27.000Z</lastmod>
    <data>
        <display>
        <title>网站存活关键，独立IP必然发展趋势！！</title>
        <content><![CDATA[<ul>
<li>今天无意中看到恒创科技独立ip主机终生3.8折全网普及活动。个人觉得很蹊跷，国内国外的iP快枯竭了，已经很紧俏了，价格应该走高才对，为什么相反便宜了？年初朋友购买过一个独立IP主机，光IP费用就180元/年。于是和几个大牛在群里讨论了一通，明白了不少新知识。</li>
<li>相信大家都经历过网站打不开的情况，主机商回答往往都是说公用IP被攻击之类的，这样就会造成很多无辜的网站受到牵连，收录及权重降低，严重的被K站，据不完全统计80%的主机故障都是这个原因造成。虽然很多站长心里都不平衡，但事实如此，确实没有好的办法来处理公用IP被攻击的问题。如果您的网站要保持高效的长久存活，那么独立ip确实以后会成为主流，这也是我的大神马云的XX网做得这么牛的原因。<h3 id="那独立IP有什么神奇之处？">那独立IP有什么神奇之处？</h3>
</li>
<li><p>一个网站使用一个ip，公用IP被攻击不收影响，对关键词排名有更大的优势。有的朋友就要问了，V4IP快枯竭了，如何谈普及，大家都不够使用啊？其我们都想错了，什么V6IP已经酝酿很久了，V4IP一旦枯竭，V6IP段肯定会出来的，那时候独立ip资源只会更多，真心不用担心IP枯竭的事。互联网在发展迅猛，对网站的稳定性要求越来越高，独立IP会像手机一样普及到每个网站。<br><img src="http://www.shenjixiang.cn/image/advertisement/hengchuang-2.png" alt=""></p>
</li>
<li><p><label class="markdownI">普及时间：即日起—2014年11月30日<br>  3.8折62%现金卷：hkduli38</label><br>1、订购两年送1年，三年送2年，五年送5年<br>2、3.8折风暴直通车：<a href="http://www.henghost.com/duli.html" target="_blank">www.henghost.com/duli.html</a></p>
</li>
</ul>
]]></content>
        <pubTime>2014-11-25T12:19:49.000Z</pubTime>
        
         
              <breadCrumb title="主机" url="http://www.shenjixiang.cn/tags/%E4%B8%BB%E6%9C%BA/"/>
          
              <breadCrumb title="主机" url="http://www.shenjixiang.cn/categories/%E4%B8%BB%E6%9C%BA/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/12/06/js-commonly/</loc>
    <lastmod>2014-12-06T07:10:07.000Z</lastmod>
    <data>
        <display>
        <title>js常用方法使用总结</title>
        <content><![CDATA[<h5 id="说明：">说明：</h5>
<ol>
<li>在项目中使用一些工具类，公共类是非常有必要的，不仅是后台，前段亦是一样</li>
<li>这里提供我收集的常用方法封装</li>
<li>代码可以在资源共享，我的代码中下载。</li>
</ol>
<h5 id="注意：">注意：</h5>
<ol>
<li>字符串的拼接一定使用StringBuffer来拼接，否则容易造成浏览器卡顿或内存溢出。特别是针对一些执行js效率不高的浏览器！！</li>
<li>经常对输入框里内容清空，对textarea，可以直接$(“textarea”).empty();如果使用$(“textarea”).html(“”);也可能会造成浏览器内存溢出！！</li>
</ol>
<h3 id="Date工具类">Date工具类</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span> date工具类 <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</div><div class="line">Date.prototype.format = function(format){</div><div class="line">	var o = {</div><div class="line">		<span class="string">"M+"</span> : this.getMonth()+1, //month</div><div class="line">		<span class="string">"d+"</span> : this.getDate(), //day</div><div class="line">		<span class="string">"h+"</span> : this.getHours(), //hour</div><div class="line">		<span class="string">"m+"</span> : this.getMinutes(), //minute</div><div class="line">		<span class="string">"s+"</span> : this.getSeconds(), //second</div><div class="line">		<span class="string">"q+"</span> : Math.floor((this.getMonth()+3)/3), //quarter</div><div class="line">		<span class="string">"S"</span> : this.getMilliseconds() //millisecond</div><div class="line">	}</div><div class="line">	if(/(y+)/.test(format)) format=format.replace(RegExp.$1,(this.getFullYear()+<span class="string">""</span>).substr(4- RegExp.$1.length));</div><div class="line">	for(var k in o)if(new RegExp(<span class="string">"("</span>+ k +<span class="string">")"</span>).test(format))</div><div class="line">	format = format.replace(RegExp.$1,RegExp.$1.length==1? o[k] : (<span class="string">"00"</span>+ o[k]).substr((<span class="string">""</span>+ o[k]).length));</div><div class="line">	return format;</div><div class="line">};</div></pre></td></tr></table></figure>

<h3 id="公共工具类">公共工具类</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/********************** 公共工具类 ***************/</span></div><div class="line"><span class="keyword">var</span> PublicUtil ={</div><div class="line">	isNotEmpty:	 <span class="function"><span class="keyword">function</span><span class="params">(val)</span></span>{</div><div class="line">		<span class="keyword">return</span> !<span class="keyword">this</span>.isEmpty(val);</div><div class="line">	},</div><div class="line">	isEmpty: <span class="function"><span class="keyword">function</span><span class="params">(val)</span></span>{</div><div class="line">		<span class="keyword">if</span> ((val==<span class="literal">null</span> || <span class="keyword">typeof</span>(val)==<span class="string">"undefined"</span>)|| (<span class="keyword">typeof</span>(val)==<span class="string">"string"</span>&&val==<span class="string">""</span>&&val!=<span class="string">"undefined"</span>)){</div><div class="line">		   <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		}</div><div class="line">	},</div><div class="line">	isDebug: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.isNotEmpty(configDebug)&&configDebug==<span class="string">"true"</span>){</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		}</div><div class="line">	},</div><div class="line">	<span class="comment">//去除元素内所有内容 strIds："#id1,#id2,#id3"</span></div><div class="line">	emptyHtml: <span class="function"><span class="keyword">function</span><span class="params">(strIds)</span></span>{</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			<span class="keyword">var</span> ids = strIds.trim(<span class="string">","</span>).split(<span class="string">","</span>);</div><div class="line">			$(ids).each(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">				<span class="keyword">var</span> obj = $(<span class="keyword">this</span>.toString());</div><div class="line">				<span class="keyword">if</span>(obj.length&gt;<span class="number">0</span>){</div><div class="line">					$(obj).each(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">						$(<span class="keyword">this</span>).html(<span class="string">""</span>);</div><div class="line">					});</div><div class="line">				}<span class="keyword">else</span>{</div><div class="line">					obj.html(<span class="string">""</span>);</div><div class="line">				}</div><div class="line">			});</div><div class="line">		}<span class="keyword">catch</span>(ex){</div><div class="line">			<span class="keyword">if</span>(PublicUtil.isDebug()){</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"js方法：【PublicUtil.emptyHtml(strIds)】，error！"</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">	},</div><div class="line">	<span class="comment">//去除元素的值 strIds："#id1,#id2,#id3"</span></div><div class="line">	emptyValue: <span class="function"><span class="keyword">function</span><span class="params">(strIds)</span></span>{</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			<span class="keyword">var</span> ids = strIds.trim(<span class="string">","</span>).split(<span class="string">","</span>);</div><div class="line">			$(ids).each(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">				<span class="keyword">var</span> obj = $(<span class="keyword">this</span>.toString());</div><div class="line">				<span class="keyword">if</span>(obj.length&gt;<span class="number">0</span>){</div><div class="line">					$(obj).each(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">						$(<span class="keyword">this</span>).val(<span class="string">""</span>);</div><div class="line">					});</div><div class="line">				}<span class="keyword">else</span>{</div><div class="line">					obj.val(<span class="string">""</span>);</div><div class="line">				}</div><div class="line">			});</div><div class="line">		}<span class="keyword">catch</span>(ex){</div><div class="line">			<span class="keyword">if</span>(PublicUtil.isDebug()){</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"js方法：【PublicUtil.emptyValue(strIds)】，error！"</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">	},</div><div class="line">	<span class="comment">//去除Textarea内所有内容 strIds："#id1,#id2,#id3"</span></div><div class="line">	emptyTextarea: <span class="function"><span class="keyword">function</span><span class="params">(strIds)</span></span>{</div><div class="line">		<span class="keyword">try</span>{</div><div class="line">			<span class="keyword">var</span> ids = strIds.trim(<span class="string">","</span>).split(<span class="string">","</span>);</div><div class="line">			$(ids).each(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">				<span class="keyword">var</span> obj = $(<span class="keyword">this</span>.toString());</div><div class="line">				<span class="keyword">if</span>(obj.length&gt;<span class="number">0</span>){</div><div class="line">					$(obj).each(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">						$(<span class="keyword">this</span>).empty();</div><div class="line">						$(<span class="keyword">this</span>).val(<span class="string">""</span>);</div><div class="line">					});</div><div class="line">				}<span class="keyword">else</span>{</div><div class="line">					obj.empty();</div><div class="line">					obj.val(<span class="string">""</span>);</div><div class="line">				}</div><div class="line">			});</div><div class="line">		}<span class="keyword">catch</span>(ex){</div><div class="line">			<span class="keyword">if</span>(PublicUtil.isDebug()){</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"js方法：【PublicUtil.emptyTextarea(strIds)】，error！"</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="String工具类">String工具类</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/********************** String工具类***************/</span></div><div class="line"><span class="comment">//trim去掉字符串两边的指定字符,默去空格</span></div><div class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span><span class="params">(tag)</span> </span>{</div><div class="line">	<span class="keyword">if</span> (!tag) { </div><div class="line">		tag = <span class="string">'\\s'</span>;</div><div class="line">	}<span class="keyword">else</span> { </div><div class="line">		<span class="keyword">if</span> (tag == <span class="string">'\\'</span>) { </div><div class="line">		tag = <span class="string">'\\\\'</span>; </div><div class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (tag == <span class="string">','</span> || tag == <span class="string">'|'</span> || tag == <span class="string">';'</span>) { </div><div class="line">			tag = <span class="string">'\\'</span> + tag; </div><div class="line">		}<span class="keyword">else</span> { </div><div class="line">			tag = <span class="string">'\\s'</span>; </div><div class="line">		} </div><div class="line">	}</div><div class="line">	<span class="built_in">eval</span>(<span class="string">'var reg=/(^'</span> + tag + <span class="string">'+)|('</span> + tag + <span class="string">'+$)/g;'</span>); </div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.replace(reg, <span class="string">''</span>);</div><div class="line">};</div><div class="line"><span class="comment">//字符串截取后面加入...</span></div><div class="line"><span class="built_in">String</span>.prototype.interceptString = <span class="function"><span class="keyword">function</span><span class="params">(len)</span> </span>{</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.length &gt; len) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.substring(<span class="number">0</span>, len) + <span class="string">"..."</span>;</div><div class="line">	} <span class="keyword">else</span> {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="comment">//将一个字符串用给定的字符变成数组</span></div><div class="line"><span class="built_in">String</span>.prototype.toArray = <span class="function"><span class="keyword">function</span><span class="params">(tag)</span> </span>{</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.indexOf(tag) != -<span class="number">1</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.split(tag);</div><div class="line">	}<span class="keyword">else</span> {</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != <span class="string">''</span>) {</div><div class="line">			<span class="keyword">return</span> [<span class="keyword">this</span>.toString()];</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> [];</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="comment">//只留下数字(0123456789)</span></div><div class="line"><span class="built_in">String</span>.prototype.toNumber= <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{ </div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/\D/g</span>, <span class="string">""</span>); </div><div class="line">}</div><div class="line"><span class="comment">//保留中文  </span></div><div class="line"><span class="built_in">String</span>.prototype.toCN= <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{  </div><div class="line">	<span class="keyword">var</span> regEx = <span class="regexp">/[^\u4e00-\u9fa5\uf900-\ufa2d]/g</span>;  </div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.replace(regEx, <span class="string">''</span>);  </div><div class="line">}</div><div class="line"><span class="comment">//转成int</span></div><div class="line"><span class="built_in">String</span>.prototype.toInt= <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{  </div><div class="line">	<span class="keyword">var</span> temp = <span class="keyword">this</span>.replace(<span class="regexp">/\D/g</span>, <span class="string">""</span>);</div><div class="line">	<span class="keyword">return</span> <span class="built_in">isNaN</span>(<span class="built_in">parseInt</span>(temp)) ? <span class="keyword">this</span>.toString() : <span class="built_in">parseInt</span>(temp);  </div><div class="line">}</div><div class="line"><span class="comment">//是否是以XX开头</span></div><div class="line"><span class="built_in">String</span>.prototype.startsWith= <span class="function"><span class="keyword">function</span><span class="params">(tag)</span></span>{</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.substring(<span class="number">0</span>, tag.length) == tag;</div><div class="line">}</div><div class="line"><span class="comment">//是否已XX结尾</span></div><div class="line"><span class="built_in">String</span>.prototype.endWith= <span class="function"><span class="keyword">function</span><span class="params">(tag)</span></span>{</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.substring(<span class="keyword">this</span>.length - tag.length) == tag;</div><div class="line">}</div><div class="line"><span class="comment">//StringBuffer</span></div><div class="line"><span class="keyword">var</span> StringBuffer = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">	<span class="keyword">this</span>._strs = <span class="keyword">new</span> <span class="built_in">Array</span>; </div><div class="line">};</div><div class="line">StringBuffer.prototype.append = <span class="function"><span class="keyword">function</span> <span class="params">(str)</span> </span>{ </div><div class="line">	<span class="keyword">this</span>._strs.push(str); </div><div class="line">}; </div><div class="line">StringBuffer.prototype.toString = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{ </div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._strs.join(<span class="string">""</span>); </div><div class="line">};</div><div class="line"><span class="built_in">String</span>.prototype.replaceAll = <span class="function"><span class="keyword">function</span><span class="params">(s1,s2)</span></span>{</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(s1,<span class="string">"gm"</span>),s2);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="Arry">Arry</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/********************** Arry ***************/</span></div><div class="line"><span class="comment">//根据数据取得再数组中的索引</span></div><div class="line"><span class="built_in">Array</span>.prototype.getIndex = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span></span>{</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) {</div><div class="line">		<span class="keyword">if</span> (obj == <span class="keyword">this</span>[i]) {</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">}</div><div class="line"><span class="comment">//移除数组中的某元素</span></div><div class="line"><span class="built_in">Array</span>.prototype.remove= <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>{</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) {</div><div class="line">		<span class="keyword">if</span> (obj == <span class="keyword">this</span>[i]) {</div><div class="line">			<span class="keyword">this</span>.splice(i, <span class="number">1</span>);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div><div class="line"><span class="comment">//判断元素是否在数组中</span></div><div class="line"><span class="built_in">Array</span>.prototype.contains= <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>{</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) {</div><div class="line">		<span class="keyword">if</span> (obj == <span class="keyword">this</span>[i]) {</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="浏览器相关操作">浏览器相关操作</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/********************** 浏览器相关操作 ***************/</span></div><div class="line"><span class="comment">//进入全屏模式,  判断各种浏览器，找到正确的方法</span></div><div class="line"><span class="keyword">var</span> launchFullScreen = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> </span>{</div><div class="line">  <span class="keyword">if</span>(element.requestFullscreen) {</div><div class="line">    element.requestFullscreen();</div><div class="line">  } <span class="keyword">else</span> <span class="keyword">if</span>(element.mozRequestFullScreen) {</div><div class="line">    element.mozRequestFullScreen();</div><div class="line">  } <span class="keyword">else</span> <span class="keyword">if</span>(element.webkitRequestFullscreen) {</div><div class="line">    element.webkitRequestFullscreen();</div><div class="line">  } <span class="keyword">else</span> <span class="keyword">if</span>(element.msRequestFullscreen) {</div><div class="line">    element.msRequestFullscreen();</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">}</div><div class="line"><span class="comment">//退出全屏模式</span></div><div class="line"><span class="keyword">var</span> exitFullScreen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">document</span>.exitFullscreen) {</div><div class="line">    <span class="built_in">document</span>.exitFullscreen();</div><div class="line">  } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.mozCancelFullScreen) {</div><div class="line">    <span class="built_in">document</span>.mozCancelFullScreen();</div><div class="line">  } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.webkitExitFullscreen) {</div><div class="line">    <span class="built_in">document</span>.webkitExitFullscreen();</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//cookie操作</span></div><div class="line"><span class="keyword">var</span> CookieUtil={</div><div class="line">	path: <span class="string">"/"</span>,</div><div class="line">	domain: <span class="string">'demo.j2ee.com'</span>,</div><div class="line">	add: <span class="function"><span class="keyword">function</span><span class="params">(name,val)</span></span>{</div><div class="line">		$.cookie(name, val, {expires: <span class="number">7</span>, path: <span class="keyword">this</span>.path, domain: <span class="keyword">this</span>.domain, secure: <span class="literal">true</span>});</div><div class="line">	},</div><div class="line">	remove: <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{</div><div class="line">		$.cookie(name, <span class="literal">null</span>,{path: <span class="keyword">this</span>.path, domain: <span class="keyword">this</span>.domain});</div><div class="line">	},</div><div class="line">	get: <span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>{</div><div class="line">		 $.cookie(name,{path: <span class="keyword">this</span>.path, domain: <span class="keyword">this</span>.domain});</div><div class="line">	}</div><div class="line">}</div><div class="line"><span class="comment">//error</span></div><div class="line"><span class="keyword">var</span> error={</div><div class="line">	 e_404: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">		 alertMessage(<span class="string">"404"</span>,<span class="string">"未找到改页面！"</span>,<span class="string">"warning"</span>);</div><div class="line">	 },</div><div class="line">	 e_500: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">		 alertMessage(<span class="string">"500"</span>,<span class="string">"服务器内部错误！"</span>,<span class="string">"error"</span>);</div><div class="line">	 },</div><div class="line">	 e_403: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">		 alertMessage(<span class="string">"403"</span>,<span class="string">"权限不足！"</span>,<span class="string">"warning"</span>);</div><div class="line">	 }</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
        <pubTime>2014-12-06T05:32:23.000Z</pubTime>
        
         
              <breadCrumb title="javascript" url="http://www.shenjixiang.cn/tags/javascript/"/>
          
              <breadCrumb title="前段" url="http://www.shenjixiang.cn/categories/%E5%89%8D%E6%AE%B5/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/04/29/ehcache-info/</loc>
    <lastmod>2014-12-06T05:35:20.000Z</lastmod>
    <data>
        <display>
        <title>ehCache的使用</title>
        <content><![CDATA[<p>1.在开发高并发量，高性能的网站应用系统时，缓存Cache起到了非常重要的作用。本文主要介绍EHCache的使用，以及使用EHCache的实践经验。<br>笔者使用过多种基于Java的开源Cache组件，其中包括OSCache、JBossCache、EHCache。OSCache功能强大，使用灵活，</p>
<p>2.可用于对象缓存、Filter缓存以及在JSP中直接使用cache标签。笔者在最近的使用过程中发现，在并发量较高时，OSCache会出现线程阻塞和数据错误，通过分析源代码发现是其内部实现的缺陷。JBossCache最大的优点是支持基于对象属性的集群同步，不过JBossCache的配置使用都较复杂，在并发量较高的情况下，对象属性数据在集群中同步也会加大系统的开销。</p>
<p>以上两种Cache本文仅作简单介绍，不做深入探讨。</p>
<p>3.EHCache是来自sourceforge（<a href="http://ehcache.sourceforge.net/）的开源项目，也是纯Java实现的简单、快速的Cache组件。" target="_blank" rel="external">http://ehcache.sourceforge.net/）的开源项目，也是纯Java实现的简单、快速的Cache组件。</a></p>
<p>EHCache支持内存和磁盘的缓存，支持LRU、LFU和FIFO多种淘汰算法，支持分布式的Cache，可以作为Hibernate的缓存插件。</p>
<p>4.同时它也能提供基于Filter的Cache，该Filter可以缓存响应的内容并采用Gzip压缩提高响应速度。</p>
<p>EHCache API的基本用法</p>
<p>首先介绍CacheManager类。它主要负责读取配置文件，默认读取CLASSPATH下的ehcache.xml，根据配置文件创建并管理Cache对象。</p>
<p>// 使用默认配置文件创建CacheManager</p>
<p>CacheManager manager = CacheManager.create();</p>
<p>// 通过manager可以生成指定名称的Cache对象</p>
<p>Cache cache = cache = manager.getCache(“demoCache”);</p>
<p>// 使用manager移除指定名称的Cache对象</p>
<p>manager.removeCache(“demoCache”);</p>
<p>可以通过调用manager.removalAll()来移除所有的Cache。通过调用manager的shutdown()方法可以关闭CacheManager。</p>
<p>有了Cache对象之后就可以进行一些基本的Cache操作，例如：</p>
<p>//往cache中添加元素</p>
<p>Element element = new Element(“key”, “value”);</p>
<p>cache.put(element);</p>
<p>//从cache中取回元素</p>
<p>Element element = cache.get(“key”);</p>
<p>element.getValue();</p>
<p>//从Cache中移除一个元素</p>
<p>cache.remove(“key”);</p>
<p>可以直接使用上面的API进行数据对象的缓存，这里需要注意的是对于缓存的对象都是必须可序列化的。</p>
<p>在下面的篇幅中笔者还会介绍EHCache和Spring、Hibernate的整合使用。</p>
<p>&#61548; 配置文件</p>
<p>配置文件ehcache.xml中命名为demoCache的缓存配置：</p>
<p>maxElementsInMemory=”10000”</p>
<p>eternal=”false”</p>
<p>overflowToDisk=”true”</p>
<p>timeToIdleSeconds=”300”</p>
<p>timeToLiveSeconds=”600”</p>
<p>memoryStoreEvictionPolic<wbr>y=”LFU” /&gt;</p>
<p>各配置参数的含义：</p>
<p>maxElementsInMemory：缓存中允许创建的最大对象数</p>
<p>eternal：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。</p>
<p>timeToIdleSeconds：缓存数据的钝化时间，也就是在一个元素消亡之前，两次访问时间的最大时间间隔值，这只能在元素不是永久驻留时有效，</p>
<p>如果该值是 0 就意味着元素可以停顿无穷长的时间。</p>
<p>timeToLiveSeconds：缓存数据的生存时间，也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，</p>
<p>如果该值是0就意味着元素可以停顿无穷长的时间。</p>
<p>overflowToDisk：内存不足时，是否启用磁盘缓存。</p>
<p>memoryStoreEvictionPolic<wbr>y：缓存满了之后的淘汰算法。LRU和FIFO算法这里就不做介绍。</p>
<p>LFU算法直接淘汰使用比较少的对象，在内存保留的都是一些经常访问的对象。对于大部分网站项目，该算法比较适用。</p>
<p>如果应用需要配置多个不同命名并采用不同参数的Cache，可以相应修改配置文件，增加需要的Cache配置即可。</p>
<p>利用Spring APO整合EHCache</p>
<p>首先，在CLASSPATH下面放置ehcache.xml配置文件。在Spring的配置文件中先添加如下cacheManager配置：</p>
<p>class=”org.springframework.cache.ehcache.EhCacheManagerFactoryBea<wbr>n”&gt;</p>
<p>配置demoCache：</p>
<p>demoCache</p>
<p>接下来，写一个实现org.aopalliance.intercept.MethodInterceptor接口的拦截器类。</p>
<p>有了拦截器就可以有选择性的配置想要缓存的 bean 方法。如果被调用的方法配置为可缓存，拦截器将为该方法生成 cache key<br>并检查该方法返回的结果是否已缓存。</p>
<p>如果已缓存，就返回缓存的结果，否则再次执行被拦截的方法，并缓存结果供下次调用。具体代码如下：<br><code><br>public class MethodCacheInterceptor implements<br>MethodInterceptor,</code></p>
<p>InitializingBean {</p>
<p>private Cache cache;</p>
<p>public void setCache(Cache cache) {</p>
<p>this.cache = cache;</p>
<p>}<br>public void afterPropertiesSet() throws Exception {</p>
<p>Assert.notNull(cache,</p>
<p>“A cache is required. Use setCache(Cache) to provide one.”);</p>
<p>}</p>
<p>public Object invoke(MethodInvocation invocation) throws Throwable<br>{</p>
<p>String targetName =<br>invocation.getThis().getClass().getName();</p>
<p>String methodName = invocation.getMethod().getName();</p>
<p>Object[] arguments = invocation.getArguments();</p>
<p>Object result;</p>
<p>String cacheKey = getCacheKey(targetName, methodName,<br>arguments);</p>
<p>Element element = null;</p>
<p>synchronized (this){</p>
<p>element = cache.get(cacheKey);</p>
<p>if (element == null) {</p>
<p>//调用实际的方法</p>
<p>result = invocation.proceed();</p>
<p>element = new Element(cacheKey, (Serializable) result);</p>
<p>cache.put(element);</p>
<p>}</p>
<p>}</p>
<p>return element.getValue();</p>
<p>}</p>
<p>private String getCacheKey(String targetName, String<br>methodName,</p>
<p>Object[] arguments) {</p>
<p>StringBuffer sb = new StringBuffer();</p>
<p>sb.append(targetName).append(“.”).append(methodName);</p>
<p>if ((arguments != null) &amp;&amp; (arguments.length != 0)) {<br>for (int i = 0; i &lt; arguments.length; i++) {<br>sb.append(“.”).append(arguments[i]);<br>}<br>}<br>return sb.toString();<br>}<br>}<br><br>synchronized<br>(this)这段代码实现了同步功能。为什么一定要同步？Cache对象本身的get和put操作是同步的。</p>
<p>如果我们缓存的数据来自数据库查询，在没有这段同步代码时，当key不存在或者key对应的对象已经过期时，</p>
<p>在多线程并发访问的情况下，许多线程都会重新执行该方法，由于对数据库进行重新查询代价是比较昂贵的，</p>
<p>而在瞬间大量的并发查询，会对数据库服务器造成非常大的压力。所以这里的同步代码是很重要的。</p>
<p>接下来，继续完成拦截器和Bean的配置：</p>
<p>.*myMethod</p>
<p>class=”com.xiebing.ehcache.spring.MyServiceBean”&gt;</p>
<p>methodCachePointCut</p>
<p>其中myServiceBean是实现了业务逻辑的Bean，里面的方法myMethod()的返回结果需要被缓存。</p>
<p>这样每次对myServiceBean的myMethod()方法进行调用,都会首先从缓存中查找,其次才会查询数据库。</p>
<p>使用AOP的方式极大地提高了系统的灵活性，通过修改配置文件就可以实现对方法结果的缓存，所有的对Cache的操作都封装在了拦截器的实现中。</p>
<p>CachingFilter功能</p>
<p>使用Spring的AOP进行整合，可以灵活的对方法的的返回结果对象进行缓存。CachingFilter功能可以对HTTP响应的内容进行缓存。</p>
<p>这种方式缓存数据的粒度比较粗，例如缓存整张页面。它的优点是使用简单、效率高，缺点是不够灵活，可重用程度不高。</p>
<p>EHCache使用SimplePageCachingFilter类实现Filter缓存。该类继承自CachingFilter，有默认产生cache<br>key的calculateKey()方法，该方法使用HTTP请求的URI和查询条件来组成key。</p>
<p>也可以自己实现一个Filter，同样继承CachingFilter类,然后覆写calculateKey()方法，生成自定义的key。</p>
<p>在笔者参与的项目中很多页面都使用AJAX，为保证JS请求的数据不被浏览器缓存，每次请求都会带有一个随机数参数i。</p>
<p>如果使用SimplePageCachingFilter，那么每次生成的key都不一样，缓存就没有意义了。这种情况下，我们就会覆写calculateKey()方法。</p>
<p>要使用SimplePageCachingFilter，首先在配置文件ehcache.xml中，增加下面的配置：</p>
<p>overflowToDisk=”false” timeToIdleSeconds=”300”<br>timeToLiveSeconds=”600”</p>
<p>memoryStoreEvictionPolic<wbr>y=”LFU” /&gt;</p>
<p>其中name属性必须为SimplePageCachingFilter，修改web.xml文件，增加一个Filter的配置：</p>
<p>SimplePageCachingFilter</p>
<p>net.sf.ehcache.constructs.web.filter.SimplePageCachingFilter</p>
<p>SimplePageCachingFilter</p>
<p>/test.jsp</p>
<p>下面我们写一个简单的test.jsp文件进行测试，缓存后的页面每次刷新，在600秒内显示的时间都不会发生变化的。代码如下：</p>
]]></content>
        <pubTime>2014-04-29T07:55:04.000Z</pubTime>
        
         
              <breadCrumb title="web" url="http://www.shenjixiang.cn/tags/web/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/10/28/ApacheMina/</loc>
    <lastmod>2014-12-06T05:35:19.000Z</lastmod>
    <data>
        <display>
        <title>Apache Mina 学习</title>
        <content><![CDATA[<p>由于项目需要，提前预备一些知识。凡是做点准备总是有好处的！！！</p>
<h3 id="MINA框架简介">MINA框架简介</h3>
<ul>
<li>MINA是用于开发高性能和高可用性的网络应用程序的基础框架</li>
<li>通过使用MINA框架可以可以省下处理底层I/O和线程并发等复杂工作，开发人员能够把更多的精力投入到业务设计和开发当中</li>
<li>MINA框架的应用比较广泛，应用的开源项目有Apache Directory、AsyncWeb、Apache Qpid、QuickFIX/J、Openfire、SubEthaSTMP、red5等。</li>
</ul>
<h3 id="MINA框架的特点">MINA框架的特点</h3>
<ul>
<li>基于java NIO类库开发；采用非阻塞方式的异步传输；</li>
<li>事件驱动；支持批量数据传输；支持TCP、UDP协议；串口通讯程序；</li>
<li>控制反转的设计模式（支持Spring）；采用优雅的松耦合架构；可灵活的加载过滤器机制；单元测试更容易实现；</li>
<li>可自定义线程的数量，以提高运行于多处理器上的性能；采用回调的方式完成调用，线程的使用更容易。</li>
</ul>
<h3 id="MINA与NETTY比较">MINA与NETTY比较</h3>
<ul>
<li>由于Netty的主导作者与Mina的主导作者是同一人，出自同一人之手的Netty在设计理念上与Mina基本上是一致的</li>
<li>Mina和Netty都是Java领域高性能和高可伸缩性网络应用程序的网络应用框架，在实际生产应用中都是不错的选择。</li>
<li>Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目</li>
</ul>
<h3 id="MINA使用简介">MINA使用简介</h3>
<ol>
<li>当客户首次访问采用MINA编写的程序时，IoAcceptor作为线程运行，负责接受来自客户的请求。</li>
<li>当有客户请求连接时，创建一个Session，该Session与IoProcessor、SocketChannel以及IOService联系起来。</li>
<li>IoProcessor也作为另外一个线程运行，定时检查(轮询)客户是否有数据到来，并对客户请求进行处理，依次调用在IOService注册的各个IoFilter，最后调用IoHandler进行最终的逻辑处理，再将处理后的结果Filter后返回给客户端。</li>
</ol>
]]></content>
        <pubTime>2014-10-28T13:23:39.000Z</pubTime>
        
         
              <breadCrumb title="通信" url="http://www.shenjixiang.cn/tags/%E9%80%9A%E4%BF%A1/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/03/24/web-zj/</loc>
    <lastmod>2014-12-06T05:35:19.000Z</lastmod>
    <data>
        <display>
        <title>web编程总结</title>
        <content><![CDATA[<p>基础知识：<br>1.B/S结构计算模式(有请求才有响应，服务器不能主动响应)。<br>2.HTML:超文本标记语言(HyperText MarkupLanguage)。<br>3.完整的web程序组成部分：网页、服务器、浏览器、HTTP协议。<br>4.客户端的网页组成部分：网页内容、结构(由XHTML)、表现形式(由css定义)、以及行为(由JavaScript和DOM定义)。</p>
<ol>
<li>一个元素：<br>内容<br>空标签：<img src="&quot;web编程总结&quot;" alt="web编程总结"><br>6.所有的XHTML文档都有三个文档级的元素：html,head,body.<br>7.常见的块级元素：div、blockquote、列表元素(dl,ol,ul)、fieldset、form、h1-h6、hr、p、pre、table等。<br>8.内嵌元素：span、a、img、label、所有的表单元素、iframe、object等。<br>9.块级元素与内嵌元素区别：块级元素会换行，而内嵌元素不会。<br>10.创建超链接的标记为：<a href="http://www.baidu.com" target="_blank" rel="external">百度</a>.创建图型<img src="&quot;web编程总结&quot;" alt="web编程总结"> .<br>11.表单：供用户输入并提交数据的图形用户界面。<br>表单(form): 输入控件元素:<br>1.input:使用type属性定义不同控件(text、password、radio<br>单选、checkbox复选框、hidden隐藏字段、file、submit、reset、image)<br>2.select和option:组合使用，创建下拉列表。<br>3.textarea:创建一个多行输入的文本框。<br>css是层叠样式表，它用于定义HTML元素的显示形式，最大优点：使内容与样式分离。<br>分为三种：1、外部样式<br>2、嵌入式<br>3、内联式<br>常用选择器：<br>1.元素选择器(p{ })<br>2.类选择器(设置属性class=”cl” .cl{ })，<br>3.D选择器(设置属性id=”id” #id{ })<br>4.包含选择器(p .cl{ })<br>5.通配符选择器(*{ })，<br>6.伪元素(p:first-line{ }第一行，p:first-letter{ } 第一个字母)<br>7.伪类选择器(a:link{ })。</li>
</ol>
]]></content>
        <pubTime>2013-03-24T14:46:11.000Z</pubTime>
        
         
              <breadCrumb title="web" url="http://www.shenjixiang.cn/tags/web/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/11/12/webampnbspservice/</loc>
    <lastmod>2014-12-06T05:35:18.000Z</lastmod>
    <data>
        <display>
        <title>web service</title>
        <content><![CDATA[<p>一个运行在web上的服务。<br> 1、web service就是远程信息访问。</p>
<p>2、是基于xml并利用soap（简单对象传输协议）实现跨平台信息传递的一种技术。<br> 3、一条soap消息就是一个普通的xml文档。</p>
<p>4、wsdl：web服务描述语言，是一个xml文档，它通过http向公众发布，告诉客户端程序关于某个具体的web<br>service服务的URL信息、方法的命名、参数、返回值等等。</p>
]]></content>
        <pubTime>2013-11-12T10:20:10.000Z</pubTime>
        
         
              <breadCrumb title="web" url="http://www.shenjixiang.cn/tags/web/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/04/25/web-servlet/</loc>
    <lastmod>2014-12-06T05:35:18.000Z</lastmod>
    <data>
        <display>
        <title>servlet/servlet处理http响应/处理请求</title>
        <content><![CDATA[<p>知识点总结：<br>servlet 是运行在web服务器或应用服务器上的java程序。<br>我们主要用的是httpservlet这个类,而servlet这个接口是由容器调用的.<br>Servlet生命周期：1.首次请求时实例化 2.初始化<br>3.service服务阶段（doGet()/doPost()反复被调用）<br>4,对象销毁(关闭浏览器或者改动过字节码时)。一个类的对象只有一个。</p>
<p>设置状态码:response.sendError(response.SC_NOT_FOUND,”Resource Not<br>Found”);response.SC_NOT_FOUND就是404。</p>
<p>设置请求重定向(客户端调转)：请求地址被移走，第二次请求地址.response.sendRedirect(“<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>“);</p>
<p>doGet()/doPost()<br>什么时候发送请求：1.点击一个超链接2.提交表单3.输入url地址回车<br>doGet()与doPost()方法的区别：<br>文本 || 文本、二进制文本<br>不超过255个字符  ||  无限制<br>url地址栏可见数据  ||<br>作为消息体，不可见<br>缓存在浏览器 ||  不被缓存</p>
<p>得到表单数据:单个：request.getParamenter(“name”),集合;requset.getParamenterValues(“name”);表单里面必须声明name属性。<br>请求转发(服务器跳转,客户端只请求一次)：RequestDispatcher rd<br>=</p>
<p>req.getRequestDispatcher(“member/MemberCenterServlet.do”);<br>// rd.forward(req, resp);//清空本页面后完成跳转，不包含本页面的内容<br>rd.include(req, resp);//包含本页面的内容</p>
]]></content>
        <pubTime>2013-04-25T14:53:48.000Z</pubTime>
        
         
              <breadCrumb title="web" url="http://www.shenjixiang.cn/tags/web/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/04/29/spring-ioc-aop/</loc>
    <lastmod>2014-12-06T05:35:17.000Z</lastmod>
    <data>
        <display>
        <title>spring的IOC和AOP</title>
        <content><![CDATA[<p>spring的IOC和AOP<br>1.解释spring的ioc? 几种注入依赖的方式？spring的优点？   </p>
<p>IOC你就认为他是一个生产和管理bean的容器就行了，原来需要在调用类中new的东西，现在都是有这个IOC容器进行产生，同<br>时，要是产生的是单例的bean，他还可以给管理bean的生命周期！<br> spring的IOC有三种注入方式 ：</p>
<p> 第一是根据属性注入 也叫set方法注入；<br>第二种是根据构造方法进行注入；<br>第三种是根据注解进行注入，这种方式我认为比较好，方便，要是bean多的话，使用前两种方式会使得配置文件过于臃肿。</p>
<p> Spring的优点：主要是根据它的IOC和AOP体现的。我感觉他就是把我们以前用到的工厂模式和代理模式进行了一个封装。<br> IOC主要是解决了代码的耦合性问题，而AOP是面向切面编程的最好解释！</p>
<p>2.解释Spring中IOC, DI, AOP<br>ioc就是控制翻转或是依赖注入。通俗的讲就是如果在什么地方需要一个对象，你自己不用去通过new 生成你需要的对象，<br>而是通过spring的bean工厂为你长生这样一个对象。<br>aop就是面向切面的编程。比如说你每做一次对数据库操作，都要生成一句日志。如果，你对数据库的操作有很多类，<br>那你每一类中都要写关于日志的方法。但是如果你用aop，那么你可以写一个方法，在这个方法中有关于数据库操作的方法，<br> 每一次调用这个方法的时候，就加上生成日志的操作。</p>
<p>3.spring的ioc/aop/代理<br>ioc是控制反转，是spring的核心思想。通过面向接口编程来实现对业务组件的动态依赖。 aop是面向<br>切面编程，它并不是只在spring或者java中才有的，它和面向对象编程（oop）是相对而言的另一种编程思想。<br> spring在实现aop编程时利用的是java的代理机制。<br>个人觉得java代理机制真的是很神奇。核心内容并不多</p>
<p>4.spring的ioc是解耦,aop是干什么的<br>     AOP面向切面编程<br>将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。 </p>
<pre><code> 比如：
</code></pre><p>很多方法可能会抛异常，你要记录这个异常到日志中去，可以写个拦截器类，在这个类中记录日志，<br>在spring.xml中配置一个对这些要记录日志的方法的aop拦截器<br>在这个方法执行后调用这个拦截器，记录日志。<br>这样就不用每次抛异常都要手动记录日志。 spring的事务管理用到的就是aop<br>这样也可以提高程序的内聚性。</p>
<p>5.讲解一下Java中Spring中IOC和AOP</p>
<p> IoC：说直白点，就是通过配置文件（XML或.properties）指定需要实例化的JAVA类（类名的完整字符串），<br>包括该JAVA类的一组初始化值，然后我们在代码中加载该配置文件，然后通过 .getBean()<br>函数就可以得到一个该JAVA类的对象，<br> 并且该对象已经根据配置文件中指定的属性值进行了初始化。<br> AOP：这个比IoC更简单，直白点说就是实现调用某个方法之前或/和之后，自动执行一系列自定义的语句</p>
<p>6.简述Spring框架中IOC和AOP<br>IOC：控制反转，是一种设计模式。一层含义是控制权的转移：由传统的在程序中控制依赖转移到由容器来控制；<br>第二层是依赖注入：将相互依赖的对象分离，在spring配置文件中描述他们的依赖关系。他们的依赖关系只在使用的时候才建立。<br>AOP：面向切面，是一种编程思想，OOP的延续。将系统中非核心的业务提取出来，进行单独处理。比如事务、日志和安全等。<br>Spring的AOP和IOC都是为了解决系统代码耦合度过高的问题。使代码重用度高、易于维护。<br>不过AOP和IOC并不是spring中特有的，只是spring把他们应用的更灵活方便 。</p>
]]></content>
        <pubTime>2014-04-29T08:35:37.000Z</pubTime>
        
         
              <breadCrumb title="web" url="http://www.shenjixiang.cn/tags/web/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/04/26/web-5/</loc>
    <lastmod>2014-12-06T05:34:43.000Z</lastmod>
    <data>
        <display>
        <title>web应用程序状态管理</title>
        <content><![CDATA[<p>http协议是一种无状态的协议，只针对一个请求响应.</p>
<p>cookie(存在于客户端,存放数据):1.不设定有效期:保存在内存中，结束会话后消失。2.设定有效期：存在磁盘上。(不安全)。<br>创建一个cookie：Cookie cookie=new<br>Cookie(“name”,username);<br>response.addCookie(cookie);<br>session(会话，存放数据比cookie安全,默认30分钟销毁)：一直存在的，直到关闭浏览器,可用来登陆状态，返回界面等等。Session对象有一个唯一的编号SessionID。使他失效：session.invalidate();<br>创建一个session对象:HttpSession<br>session=requset.getSession();</p>
<p>session.setAttribute(“name”,name);</p>
<p>传输数据：session/cookie/response/requset</p>
]]></content>
        <pubTime>2013-04-25T16:08:33.000Z</pubTime>
        
         
              <breadCrumb title="web" url="http://www.shenjixiang.cn/tags/web/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
    
  <url>
    <loc>http://www.shenjixiang.cn/2014/12/02/hibernate-cache/</loc>
    <lastmod>2014-12-02T12:39:17.000Z</lastmod>
    <data>
        <display>
        <title>hibernate的缓存机制</title>
        <content><![CDATA[<h5 id="之前在校写的，今天放上来，适合java初学者。总的来说分为两类：">之前在校写的，今天放上来，适合java初学者。总的来说分为两类：</h5>
<h3 id="session缓存(一级缓存):">session缓存(一级缓存):</h3>
<ul>
<li>必须有的，不能被卸载，由于Session对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。</li>
<li>在一级缓存中，每个持久化类的实例都有一个对应的OID.</li>
</ul>
<h3 id="sessionFactory缓存(二级缓存):">sessionFactory缓存(二级缓存):</h3>
<ul>
<li>默认不启用，需手动配置，属于进程范围的缓存，可能出现并发的情况，需使用适当的访问策略。</li>
<li>hibernate根据id访问数据是，首先到一级缓存去查找，找不到，再看有没有二级缓存，查二级缓存里面有没有数据，如果没有再到数据库查询，再根据id将数据放入缓存中。删除、更新、增加数据的时候，同时更新缓存。</li>
</ul>
]]></content>
        <pubTime>2014-12-02T12:00:45.000Z</pubTime>
        
         
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/tags/j2EE/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/11/24/jdk-dispatcher/</loc>
    <lastmod>2014-11-24T13:16:57.000Z</lastmod>
    <data>
        <display>
        <title>jdk自带的两种任务调度器</title>
        <content><![CDATA[<p><strong>注：本文只介绍了两种jdk自带的两种任务调度器，根据实际情况使用。更多更复杂的调度需求可以使用Quartz</strong></p>
<h3 id="1-_JDK_TimerTask">1. JDK TimerTask</h3>
<ul>
<li><h5 id="介绍">介绍</h5>
<p>  Timer 适用于简单任务调度，相当于线程休眠后执行task。<br>  所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，<br>  同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p>
</li>
<li><h5 id="使用方法">使用方法</h5>
<p>其中 Timer 负责设定 TimerTask 的起始与间隔执行时间。使用者只需要创建一个 TimerTask 的继承类，实现自己的 run 方法，然后将其丢给 Timer 去执行即可。</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>{</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String jobName = <span class="string">""</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">TimerTest</span>(String jobName) {</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.jobName = jobName;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		System.out.println(<span class="string">"execute "</span> + jobName);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> InterruptedException {</div><div class="line">		Timer timer = <span class="keyword">new</span> Timer();</div><div class="line">		<span class="keyword">long</span> delay1 = <span class="number">1</span> * <span class="number">1000</span>;</div><div class="line">		<span class="keyword">long</span> period1 = <span class="number">1000</span>;</div><div class="line">		<span class="comment">// 从现在开始 1 秒钟之后，每隔 1 秒钟执行一次 job1</span></div><div class="line">		timer.schedule(<span class="keyword">new</span> TimerTest(<span class="string">"job1"</span>), delay1, period1);</div><div class="line">		<span class="keyword">long</span> delay2 = <span class="number">2</span> * <span class="number">1000</span>;</div><div class="line">		<span class="keyword">long</span> period2 = <span class="number">2000</span>;</div><div class="line">		<span class="comment">// 从现在开始 2 秒钟之后，每隔 2 秒钟执行一次 job2</span></div><div class="line">		timer.schedule(<span class="keyword">new</span> TimerTest(<span class="string">"job2"</span>), delay2, period2);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="2-_JDK_ScheduledExecutor">2. JDK ScheduledExecutor</h3>
<ul>
<li><h5 id="介绍-1">介绍</h5>
<p>  Java 5 推出了基于线程池设计的 ScheduledExecutor<br>  原理：</p>
<ol>
<li>每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。</li>
<li>需要注意的是，只有当任务的执行时间到来时，ScheduedExecutor 才会真正启动一个线程，其余时间 ScheduledExecutor 都是在轮询任务的状态。</li>
</ol>
</li>
<li><h5 id="使用方法-1">使用方法</h5>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</div><div class="line">	<span class="keyword">private</span> String jobName = <span class="string">""</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">ScheduledExecutorTest</span>(String jobName) {</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.jobName = jobName;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">		System.out.println(<span class="string">"execute "</span> + jobName);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		<span class="comment">//初始化线程池</span></div><div class="line">		ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</div><div class="line"></div><div class="line">		<span class="keyword">long</span> initialDelay1 = <span class="number">1</span>;</div><div class="line">		<span class="keyword">long</span> period1 = <span class="number">1</span>;</div><div class="line">		<span class="comment">// 从现在开始1秒钟之后，每隔1秒钟执行一次job1。ScheduleAtFixedRate：每次执行时间为上一次任务开始起向后推一个时间间隔</span></div><div class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> ScheduledExecutorTest(<span class="string">"job1"</span>),</div><div class="line">				initialDelay1, period1, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">		<span class="keyword">long</span> initialDelay2 = <span class="number">1</span>;</div><div class="line">		<span class="keyword">long</span> delay2 = <span class="number">1</span>;</div><div class="line">		<span class="comment">// 从现在开始2秒钟之后，每隔2秒钟执行一次job2。scheduleWithFixedDelay：每次执行时间为上一次任务结束起向后推一个时间间隔</span></div><div class="line">		service.scheduleWithFixedDelay(<span class="keyword">new</span> ScheduledExecutorTest(<span class="string">"job2"</span>),</div><div class="line">				initialDelay2, delay2, TimeUnit.SECONDS);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
        <pubTime>2014-11-24T13:08:19.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/10/23/mysql-cluster/</loc>
    <lastmod>2014-10-28T13:38:06.000Z</lastmod>
    <data>
        <display>
        <title>mysql集群搭建</title>
        <content><![CDATA[<h3 id="集群常用架构">集群常用架构</h3>
<p>由于时间关系，项目目前暂停</p>
]]></content>
        <pubTime>2014-10-23T13:23:39.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="分布式" url="http://www.shenjixiang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
          
        </display>
    </data>
    </url>

    
    
    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/16/zookeeper-2/</loc>
    <lastmod>2014-10-12T13:50:08.000Z</lastmod>
    <data>
        <display>
        <title>使用shell脚本启动zookeeper集群</title>
        <content><![CDATA[<h2 id="步骤">步骤</h2>
<ul>
<li>采用shell脚本启动zookeeper，首先新建文件start.sh</li>
<li>写入内容（rh1 rh2 rh3 分别是主机名。此处需要ssh）：#!/bin/sh<br>echo “start zkServer…”<br>for i in rh1 rh2 rh3<br>do<br>ssh $i “/usr/local/zookeeper3.4/bin/zkServer.sh start”<br>done</li>
<li>写好后保存，加上执行权限：chmod u+x start.sh</li>
<li>运行：./start.sh</li>
<li>你会看见是启动成功了的，有输出。但是你输入jps查看的时候，会发现没有QuorumPeerMain 进程。说明没有启动成功。</li>
</ul>
<h2 id="分析原因">分析原因</h2>
<ul>
<li>首先需要知道 交互式shell和非交互式shell、登录shell和非登录shell是有区别的</li>
<li>在登录shell里，环境信息需要读取/etc/profile和~ /.bash_profile, ~/.bash_login, and ~/.profile按顺序最先的一个，并执行其中的命令。除非被 —noprofile选项禁止了；</li>
<li>在非登录shell里，环境信息只读取 /etc/bash.bashrc和~/.bashrc 手工执行是属于登陆shell，脚本执行数据非登陆shell，而我的linux环境配置中只对/etc/profile进行了jdk1.6等环境的配置，所以脚本执行/usr/local/zookeeper3.4/bin/zkServer.sh start 启动zookeeper失败了</li>
</ul>
<h2 id="解决方法">解决方法</h2>
<ul>
<li>把profile的配置信息echo到.bashrc中  echo ‘source /etc/profile’ &gt;&gt; ~/.bashrc</li>
<li>在/zookeeper/bin/zkEnv.sh的中开始位置添加 export JAVA_HOME=/usr/local/jdk1.6（就像hadoop中对hadoop-env.sh的配置一样） </li>
<li>启动再看看</li>
</ul>
]]></content>
        <pubTime>2014-09-16T14:35:00.000Z</pubTime>
        
         
              <breadCrumb title="zookeeper" url="http://www.shenjixiang.cn/tags/zookeeper/"/>
          
              <breadCrumb title="zookeeper" url="http://www.shenjixiang.cn/categories/zookeeper/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/02/10/single-good/</loc>
    <lastmod>2014-10-07T08:23:15.000Z</lastmod>
    <data>
        <display>
        <title>单列模式（双重校验锁定）非常好的一种</title>
        <content><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Singleton {</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton s;</div><div class="line">	<span class="keyword">private</span> <span class="title">Singleton</span>() {}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">get</span>() {</div><div class="line">		<span class="keyword">if</span> (s == <span class="keyword">null</span>) {</div><div class="line">			synchronized (Singleton.class) {</div><div class="line">				<span class="keyword">if</span> (s == <span class="keyword">null</span>) {</div><div class="line">					s = <span class="keyword">new</span> Singleton();</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
        <pubTime>2014-02-10T06:51:17.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/03/25/nginxtomcatmemcached/</loc>
    <lastmod>2014-10-07T08:21:57.000Z</lastmod>
    <data>
        <display>
        <title>Nginx+Tomcat+MemCached_集群配置</title>
        <content><![CDATA[<p>Nginx是一个高性能的 HTTP 和 反向代理服务器；Nginx 支持简单的负载均衡和容错；Nginx支持作为基本<br>HTTP 服务器的功能。<br>Memcached<br>是一个高性能的分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，Memcached能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。<br>一、<br>安装nginx-1.5.12<br>memcached-win64-1.4.4-14<br>apache-tomcat-6.0.33-1  注意设置端口号<br>apache-tomcat-6.0.33-2  注意设置端口号<br>配号后启动tomcat看是否正常运行。<br>二、除此之外，我们还需要一些MSM相关的jar包：<br>javolution-5.4.3.1.jar<br>memcached-2.4.2.jar<br>memcached-session-manager-1.5.1.jar<br>memcached-session-manager-tc6-1.5.1.jar<br>msm-javolution-serializer-1.5.1.jar<br>msm-kryo-serializer-1.5.1.jar<br>msm-xstream-serializer-1.5.1.jar<br>以上jar包在<a href="http://code.google.com/p/memcached-session-manager/downloads/list中下载。" target="_blank" rel="external">http://code.google.com/p/memcached-session-manager/downloads/list中下载。</a></p>
<p>1.1   配置Session共享<br>一、将上面所述的MSM的jar包拷贝至Tomcat安装目录lib文件夹中；<br>二、编辑context.xml<br>className=”de.javakaffee.web.msm.MemcachedBackupSessionManager”<br>memcachedNodes=”n1:shenjixiang.cn:11211”<br>requestUriIgnorePattern=”.*/.(png|gif|jpg|css|js)$”<br>sessionBackupAsync=”false”<br>sessionBackupTimeout=”100”<br>transcoderFactoryClass=”de.javakaffee.web.msm.serializer.javolution.JavolutionTranscoderFactory”<br>copyCollectionsForSerialization=”false”/&gt; </p>
<p>1.2   配置Nginx负载均衡</p>
<p>一、Nginx安装完毕后，修改配置文件conf/nginx.conf</p>
<p>http {</p>
<p>include       mime.types;</p>
<p>default_type  application/octet-stream;</p>
<p>sendfile        on;</p>
<p>keepalive_timeout  65;</p>
<p>upstream web_server {</p>
<p>#ip_hash;</p>
<p>server 192.168.134.135:8080 max_fails=3  fail_timeout=30s;</p>
<p>server 192.168.134.136:8080 max_fails=3  fail_timeout=30s;</p>
<p>}</p>
<p>server {</p>
<p>listen       80;</p>
<p>server_name  localhost;</p>
<p>location ~ .*.jsp$ {</p>
<p>proxy_pass   <a href="http://web_server" target="_blank" rel="external">http://web_server</a>;</p>
<p>proxy_redirect default ;</p>
<p>}</p>
<p>location / {</p>
<p>root   html;</p>
<p>index  index.html index.htm;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>二、重启Nginx</p>
<p>1.3   测试</p>
<p>在两个Tomcat的webapps目录，在ROOT目录下，创建test.jsp文件，文件内容如下：</p>
<p>&lt;%@ page contentType=”text/html; charset=GBK” %&gt;</p>
<p>&lt;%@ page import=”java.util.*” %&gt;</p>
<p>&lt;html&gt;&lt;head&gt;&lt;title&gt;Cluster App Test&lt;/title&gt;&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>Server Info:</p>
<p>&lt;%</p>
<p>out.println(request.getLocalAddr() + “:” + request.getLocalPort());</p>
<p>%&gt;</p>
<p>&lt;br&gt;&lt;br&gt;</p>
<p>&lt;%</p>
<p>out.println(“&lt;br&gt; ID “ + session.getId()+”&lt;br&gt;”);</p>
<p>String dataName = request.getParameter(“dataName”);</p>
<p>if (dataName != null &amp;&amp; dataName.length() &gt; 0) {</p>
<p>String dataValue = request.getParameter(“dataValue”) ;</p>
<p>session.setAttribute(dataName, dataValue);</p>
<p>}</p>
<p>out.print(“&lt;b&gt;Session list&lt;/b&gt; &lt;br&gt;”);</p>
<p>Enumeration e = session.getAttributeNames();</p>
<p>while (e.hasMoreElements()) {</p>
<p>String name = (String)e.nextElement();</p>
<p>String value = session.getAttribute(name).toString();</p>
<p>out.println( name + “ = “ + value+”&lt;br&gt;”);</p>
<p>System.out.println( name + “ = “ + value);</p>
<p>}</p>
<p>%&gt;</p>
<p>&lt;form action=”test_session.jsp” method=”POST”&gt;</p>
<p>name:&lt;input type=text size=20 name=”dataName”&gt; &lt;br&gt;</p>
<p>key:&lt;input type=text size=20 name=”dataValue”&gt; &lt;br&gt;</p>
<p>&lt;input type=submit&gt;</p>
<p>&lt;/form&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>测试步骤:</p>
<p>先启动memcached  cd F:\javaNTM\memcached-win64</p>
<p>memcached.exe -p 11211 -d start</p>
<p>然后启动niginx  cd F:\javaNTM\nginx-1.5.12</p>
<p>输入：    start nginx</p>
<p>输入：    nginx -t</p>
<p>重启：    nginx -s reload</p>
<p>如果出现：</p>
<p>nginx: the configuration file F:\javaNTM\nginx-1.5.12/conf/nginx.conf syntax is</p>
<p>ok</p>
<p>nginx: configuration file F:\javaNTM\nginx-1.5.12/conf/nginx.conf test is succes</p>
<p>sful</p>
<p>这样就表示启动成功</p>
<p>然后启动两个Tomcat。</p>
<p>打开浏览器，输入<a href="http://localhost/" target="_blank" rel="external">http://localhost</a>:/test.jsp</p>
<p>填写name和key，提交后看以看到</p>
<p>关闭一个Tomcat，再刷新，如果ID的值相同且Session List中值也存在，说明Session是被共享的。这样Nginx+Tomcat+MemCached_集群环境就搭建好了</p>
]]></content>
        <pubTime>2014-03-25T06:49:39.000Z</pubTime>
        
         
              <breadCrumb title="分布式" url="http://www.shenjixiang.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
          
              <breadCrumb title="分布式" url="http://www.shenjixiang.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/15/zookeeper-1/</loc>
    <lastmod>2014-09-16T14:36:23.000Z</lastmod>
    <data>
        <display>
        <title>zookeeper安装配置及简介</title>
        <content><![CDATA[<h2 id="zookeeper简介">zookeeper简介</h2>
<ul>
<li>zookeeper是一个为分布式应用所设计的开源协调服务。为用户提供同步、配置管理、分组和命名等服务。目的为减轻分布式应用所承担的协调任务。</li>
<li>可使用zookeeper提供的接口方便的实现一致性、组管理、leader选举及某些协议。</li>
</ul>
<h2 id="zookeeper安装">zookeeper安装</h2>
<ul>
<li>zookeeper可以在不同的系统中运行，比如linux，solaris，FreeBSD、win32、MacOSX</li>
<li>安装条件：java1.6以上，至少三个节点。一般为奇数个</li>
<li>首先到官网下载最新版本zookeeper</li>
<li>解压：<br>加执行权限：chmod u+x zookeeper-3.4.5.tar.gz<br>tar -zxvf zookeeper-3.4.5.tar.gz<br>重命名：mv zookeeper-3.4.5 zookeeper3.4</li>
<li>环境变量配置<br>vi /etc/profile<br>加入<br>export ZOOKEEPER_HOME=/usr/local/zookeeper3.4<br>export PATH=$ZOOKEEPER_HOME/conf:$ZOOKEEPER_HOME/bin:$PATH<br>保存退出，记得source一下，使其文件生效</li>
</ul>
<h2 id="zookeeper配置">zookeeper配置</h2>
<ul>
<li>配置zookeeper：在conf下新建一个zoo.cfg文件</li>
<li>心跳时间，单位毫秒。最小的会话超时为tickTime的2倍<br>tickTime=2000</li>
<li>存储内存中数据库快照的位置<br>dataDir=/usr/local/zookeeper3.4/tmp</li>
<li>允许follower(相对leader的客户端)连接并同步到leader的初始化连接时间，为tickTime的倍数。</li>
<li>不能超过tickTime<br>initLimit=20</li>
<li>表示leader与follower之间请求与应答时间长度。</li>
<li>如果不能在指定时间内通信，那么视follower宕机。将被丢弃。<br>syncLimit=10</li>
<li>监听客户端连接端口<br>clientPort=2181</li>
<li>日志路径<br>dataLogDir=/usr/local/zookeeper3.4/log</li>
<li>server.1代表标示不同的服务器,必须唯一。myid文件里的值</li>
<li>2888端口用于连接主机器，3888用于leader选举<br>server.1=rh1:2888:3888<br>server.2=rh2:2888:3888<br>server.3=rh3:2888:3888</li>
<li>以上均为一般配置，以下为特殊需要配置</li>
<li>限制zookeeper客户端的数量，通过ip来限制并发数。</li>
<li>0为取消限制<br>maxClientCnxns=3</li>
<li>minSessionTimeout=1000</li>
<li>maxSessionTimeout=50000</li>
</ul>
<h1 id="启动zookeeper">启动zookeeper</h1>
<ul>
<li>运行前注意目录是否存在，myid文件是否存在。必须需要在每台机子上输入命令：/usr/local/zookeeper3.4/bin/zkServer.sh start。刚开始会报错，因为其他机器的zookeeper还没跑起来</li>
<li>如有报错请看zookeeper.out文件里的内容</li>
</ul>
]]></content>
        <pubTime>2014-09-15T13:05:47.000Z</pubTime>
        
         
              <breadCrumb title="zookeeper" url="http://www.shenjixiang.cn/tags/zookeeper/"/>
          
              <breadCrumb title="zookeeper" url="http://www.shenjixiang.cn/categories/zookeeper/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/13/pig-2/</loc>
    <lastmod>2014-09-14T14:54:36.000Z</lastmod>
    <data>
        <display>
        <title>Pig Latin语言</title>
        <content><![CDATA[<h2 id="Pig_Latin语言简介">Pig Latin语言简介</h2>
<ul>
<li>与传统的关系数据库中的操作非常相似，但是更侧重于查询与分析</li>
<li>程序员无需关心运行效率，更专注于程序的编写</li>
<li>通常安照以下流程来编写<ul>
<li>通过一条load语句从文件系统中读取数据</li>
<li>通过一系列“转换”语句对数据进行处理</li>
<li>通过一条store语句把处理结果输出到文件系统中，或者通过DUMP语句输出到屏幕上</li>
</ul>
</li>
</ul>
<h2 id="Pig_Latin的数据类型">Pig Latin的数据类型</h2>
<ul>
<li>数据模式<ul>
<li>组织形式包括：关系(relation)、包(bag)、元组(tuple)和域(field)</li>
<li>一个关系就是一个包</li>
<li>包是元组的集合</li>
<li>元组是域的有序集合</li>
<li>域是一个数据块</li>
<li>一个pig关系是一个有元组组成的包，pig中的关系和关系数据库中的表很相似，包的元组相当于表中的行。pig中不需要每一个元组包含相同数目或者相同位置的域，也不需要具有相同的数据类型。</li>
<li>关系是无序的，所以pig不能保证元组按特定的顺序来执行</li>
</ul>
</li>
<li>数据类型<br><img src="http://www.shenjixiang.cn/image/pig/pig-data-type.jpg" alt="pig数据类型"><br><img src="http://www.shenjixiang.cn/image/pig/pig-data-type-2.jpg" alt="pig数据类型2"></li>
<li>pig常用关键字<ul>
<li>关系运算符<br>— load ‘data’ [using 函数] [as 字段类型] ;<br>列如：load ‘myfile.txt’ using PigStorage(‘\t’) as(f1:int,f2:int,f3:int);<br>— store：将结果保存到文件系统中，语法如下：<br>store 关系名称 into ‘目录名’ [using 函数]<br>— Foreach：基于数据的列进行数据转换</li>
<li>诊断运算符<br>— Dump：dump 关系名<br>A=load ‘file.txt’ as (name:chararray,age:int,gpa:float);<br>dump A;<br>这里pig将A中的数据显示在屏幕上<br>— Describe：作用是返回一个名称的模式<br>— load/store函数：作用是加载、存储utf-8格式的数据，语法如下：<br>PigStorage(‘\t’) ‘\t’为与域界定符，’\t’为默认值</li>
</ul>
</li>
</ul>
<h2 id="如何使用Pig_Latin语言">如何使用Pig Latin语言</h2>
<ul>
<li>输入pig -x mapreduce进入Grunt Shell方式</li>
</ul>
]]></content>
        <pubTime>2014-09-13T06:44:05.000Z</pubTime>
        
         
              <breadCrumb title="Pig" url="http://www.shenjixiang.cn/tags/Pig/"/>
          
              <breadCrumb title="Pig" url="http://www.shenjixiang.cn/categories/Pig/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/12/pig-1/</loc>
    <lastmod>2014-09-12T15:23:31.000Z</lastmod>
    <data>
        <display>
        <title>了解pig及安装</title>
        <content><![CDATA[<h2 id="什么是pig_?">什么是pig ?</h2>
<ul>
<li>Pig是一个基于Hadoop的大规模数据分析平台，它提供的SQL-LIKE语言叫Pig Latin，该编译器会把请求自动优化并处理MapReduce运算，这样使Pig易于编程，不用担心效率。自动对集群分配和回收。</li>
<li>Pig可加载数据、表达转换数据以及存储最终结果。Pig可扩展使用Java中添加的自定义数据类型并支持数据转换。</li>
<li>Pig与Hive相比。Hive更适合于数据仓库的任务。Pig赋予开发人员在大数据集领域更多的灵活性，并允许开发简洁的脚本用于转换数据流以便嵌入到较大的 应用程序。Pig相比Hive相对轻量，它主要的优势是相比于直接使用Hadoop Java APIs可大幅削减代码量。</li>
<li>Hive与SQL相似促使 其成为Hadoop与其他BI工具结合的理想交集。</li>
</ul>
<h2 id="pig安装">pig安装</h2>
<ul>
<li>解压：<br>加执行权限：chmod u+x pig-0.13.0.tar.gz<br>tar -zxvf pig-0.13.0.tar.gz<br>重命名：mv pig-0.13.0 pig0.13</li>
<li>环境变量配置（几乎每安装一个都需配置/etc/profile）</li>
<li>vi /etc/profile<br>加入<br>export PIG_HOME=/usr/local/pig0.13<br>export PATH=$PIG_HOME/conf:$PIG_HOME/bin:$PATH</li>
<li>保存退出，记得source一下，使其文件生效</li>
<li>使用命令 pig -help看看有没有安装成功</li>
</ul>
<h2 id="启动pig">启动pig</h2>
<ul>
<li>pig运行分为local模式和mapReduce模式，这里采用mapReduce模式。</li>
<li>运行方式：<ol>
<li>Grunt Shell方式：输入pig -x mapreduce进入</li>
<li>脚本文件方式：输入pig -x mapreduce script.pig运行脚本</li>
<li>嵌入式程序：首先编译：javac -cp pig-0.13.0-h1.jar mapreduce.java 然后执行：java -cp pig-0.13.0-h1.jar mapreduce</li>
</ol>
</li>
</ul>
]]></content>
        <pubTime>2014-09-12T14:30:45.000Z</pubTime>
        
         
              <breadCrumb title="Pig" url="http://www.shenjixiang.cn/tags/Pig/"/>
          
              <breadCrumb title="Pig" url="http://www.shenjixiang.cn/categories/Pig/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/10/mahout-2/</loc>
    <lastmod>2014-09-10T14:51:29.000Z</lastmod>
    <data>
        <display>
        <title>深入了解Mahout算法</title>
        <content><![CDATA[<h2 id="频繁模式挖掘">频繁模式挖掘</h2>
<ul>
<li>比如“尿布与啤酒的故事”，尿布与啤酒的经常一同出现便是一组频繁模式，还有例如购物篮数据分析、交叉购物、DNA序列分析、预测分析。</li>
<li>经典的频繁模式挖掘包括Apriori算法、fpgrowth算法、AGM算法、PrefixSapn算法等等…</li>
<li>使用命令：mahout fpg来进行频繁模式挖掘<br><img src="http://www.shenjixiang.cn/image/mahout/mahout-fpg-cfg.jpg" alt="mahout-fpg-命令参数"></li>
</ul>
<h2 id="聚类和分类">聚类和分类</h2>
<ul>
<li>我的理解聚类就是将大致相似的东西放在一起，还可再聚类。分类就是很明确的分清楚这是什么</li>
<li>还有很多很多东西，比如构建一个推荐引擎，这里暂时不讲</li>
</ul>
]]></content>
        <pubTime>2014-09-10T14:03:26.000Z</pubTime>
        
         
              <breadCrumb title="Mahout" url="http://www.shenjixiang.cn/tags/Mahout/"/>
          
              <breadCrumb title="Mahout" url="http://www.shenjixiang.cn/categories/Mahout/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/09/mahout-1/</loc>
    <lastmod>2014-09-10T14:00:26.000Z</lastmod>
    <data>
        <display>
        <title>Mahout了解及配置</title>
        <content><![CDATA[<h2 id="了解">了解</h2>
<ul>
<li>apache Mahout主要是建立可伸缩的机器学习算法。针对大规模的数据。</li>
<li>apache Mahout的算法运行在hadoop下，通过mapreduce实现。也可不依赖hadoop，即非分布式算法。</li>
<li>该项目主要包括以下五部分：<br>— 频繁模式挖掘：挖掘数据中频繁出现的项集<br>— 聚类：将文本、文档之类的数据分成局部相关的组<br>— 分类：利用已存在的分类文档训练分类器，对未分类的文档进行分类<br>— 推荐引擎（协同过滤）：获得用户的行为并从中发现用户可能喜欢的事物<br>— 频繁子项挖掘：利用一个项集（查询记录或购物目录）去识别经常一起出现的项目<br>— 目前已经有很多技术的算法了</li>
</ul>
<h2 id="安装Mahout">安装Mahout</h2>
<ul>
<li>Mahout可在本地模式下运行，也可运行在hadoop下，此处运行在hadoop下。到<a href="http://apache.fayea.com/apache-mirror/mahout/" target="_blank" rel="external">mahout下载</a></li>
<li>解压：<br>— 加权限:chmod u+x mahout-distribution-0.9.tar.gz<br>— tar -zxvf mahout-distribution-0.9.tar.gz</li>
<li>配置环境变量<br>— 使用命令 vi /etc/profile<br>— export MAHOUT_HOME=/usr/local/mahout0.9<br>— export MAHOUT_CONF_DIR=$MAHOUT_HOME/conf<br>— export PATH=$MAHOUT_HOME/conf:$MAHOUT_HOME/bin:$PATH<br>— 保存退出，source一下。使用mahout -help看看是否安装成功</li>
</ul>
]]></content>
        <pubTime>2014-09-09T14:31:39.000Z</pubTime>
        
         
              <breadCrumb title="Mahout" url="http://www.shenjixiang.cn/tags/Mahout/"/>
          
              <breadCrumb title="Mahout" url="http://www.shenjixiang.cn/categories/Mahout/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/04/hbase-3/</loc>
    <lastmod>2014-09-08T15:52:33.000Z</lastmod>
    <data>
        <display>
        <title>hbase客户端操作</title>
        <content><![CDATA[<h2 id="Rest和Thrift接口">Rest和Thrift接口</h2>
<ul>
<li>hbase的rest和thrift接口支持xml、protobuf、和二进制数据编码等操作</li>
</ul>
<h2 id="java_API">java API</h2>
<ul>
<li>大体包括：hbase自身管理部分、avro部分、hbase客户端部分、mapreduce部分、rest部分、thrift部分、zookeeper等等。<br><img src="http://www.shenjixiang.cn/image/hbase/hbaseJavaAPI.jpg" alt="hbaseJavaAPI"></li>
<li>使用Eclipse开发HBase<ul>
<li>第三方访问hbase时，首先需访问zookeeper，因为hbase重要信息保存在zookeeper中，而zookeeper集群是由hbase-site.xml指定的，所以需找到hbase-site.xml文件。通过classpath来指定</li>
<li>将所需jar包（hbase的lib目录下全部加上hadoop-core-1.x.jar，window下注意fileUtil类去掉check），拷贝hbse-site.xml到项目目录下，在libraries里点add class folder选择hbase-site.xml目录</li>
<li>列子：输入hdfs上的两个文件，采用mapReduce统计，输出结果到Hbase中。</li>
</ul>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HColumnDescriptor;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.HTableDescriptor;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.HBaseAdmin;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.Put;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableOutputFormat;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.mapreduce.TableReducer;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.NullWritable;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</div><div class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.TextInputFormat;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HBaseWordCount</span> </span>{	</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt;</span>{</div><div class="line">	<span class="annotation">@Override</span></div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span>(LongWritable key, Text value, Context context)</div><div class="line">			<span class="keyword">throws</span> IOException, InterruptedException {</div><div class="line">		String[] s = value.toString().trim().split(<span class="string">" "</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (String str : s) {</div><div class="line">			context.write(<span class="keyword">new</span> Text(str), <span class="keyword">new</span> IntWritable(<span class="number">1</span>));</div><div class="line">		}</div><div class="line">	}</div><div class="line">}	</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> <span class="keyword">extends</span> <span class="title">TableReducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">NullWritable</span>&gt;</span>{</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span>(Text key, Iterable&lt;IntWritable&gt; values,Context context)</div><div class="line">			<span class="keyword">throws</span> IOException, InterruptedException {</div><div class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (IntWritable i : values) {</div><div class="line">			sum+=i.get();</div><div class="line">		}</div><div class="line">		Put put= <span class="keyword">new</span> Put(Bytes.toBytes(key.toString()));</div><div class="line">		<span class="comment">//列族为content，修饰符为count，列值数目</span></div><div class="line">		put.add(Bytes.toBytes(<span class="string">"content"</span>),Bytes.toBytes(<span class="string">"count"</span>),Bytes.toBytes(String.valueOf(sum)));</div><div class="line">		context.write(NullWritable.get(), put);</div><div class="line">	}		</div><div class="line">}	</div><div class="line"><span class="annotation">@SuppressWarnings</span>({ <span class="string">"deprecation"</span>, <span class="string">"resource"</span> })</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createHBaseTable</span>(String table) <span class="keyword">throws</span> Exception{</div><div class="line">	HTableDescriptor htd = <span class="keyword">new</span> HTableDescriptor(table);</div><div class="line">	HColumnDescriptor col = <span class="keyword">new</span> HColumnDescriptor(<span class="string">"content"</span>);</div><div class="line">	htd.addFamily(col);</div><div class="line">	HBaseConfiguration config = <span class="keyword">new</span> HBaseConfiguration();</div><div class="line">	HBaseAdmin admin = <span class="keyword">new</span> HBaseAdmin(config);</div><div class="line">	<span class="keyword">if</span>(admin.tableExists(table)){</div><div class="line">		System.out.println(<span class="string">"table:'"</span>+table+<span class="string">"' exits"</span>);</div><div class="line">		admin.disableTable(table);</div><div class="line">		admin.deleteTable(table);</div><div class="line">	}</div><div class="line">	System.out.println(<span class="string">"create '"</span>+table+<span class="string">"' table"</span>);</div><div class="line">	admin.createTable(htd);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> Exception {</div><div class="line">	String tableName = <span class="string">"wordcount"</span>;</div><div class="line">	Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">	conf.set(TableOutputFormat.OUTPUT_TABLE, tableName);</div><div class="line">	createHBaseTable(tableName);		</div><div class="line">	Job job = <span class="keyword">new</span> Job(conf,<span class="string">"wordcount table with "</span>+args[<span class="number">0</span>]);</div><div class="line">	job.setJarByClass(HBaseWordCount.class);</div><div class="line">	job.setNumReduceTasks(<span class="number">3</span>);</div><div class="line">	job.setMapperClass(Map.class);</div><div class="line">	job.setReducerClass(Reduce.class);</div><div class="line">	job.setMapOutputKeyClass(Text.class);</div><div class="line">	job.setMapOutputValueClass(IntWritable.class);</div><div class="line">	job.setInputFormatClass(TextInputFormat.class);</div><div class="line">	job.setOutputFormatClass(TableOutputFormat.class);</div><div class="line">	FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</div><div class="line">	System.exit(job.waitForCompletion(<span class="keyword">true</span>)?<span class="number">0</span>:<span class="number">1</span>);</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>



]]></content>
        <pubTime>2014-09-04T14:23:13.000Z</pubTime>
        
         
              <breadCrumb title="HBase" url="http://www.shenjixiang.cn/tags/HBase/"/>
          
              <breadCrumb title="HBase" url="http://www.shenjixiang.cn/categories/HBase/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/03/hbase-2/</loc>
    <lastmod>2014-09-08T10:40:23.000Z</lastmod>
    <data>
        <display>
        <title>hbase体系结构</title>
        <content><![CDATA[<h2 id="主从架构">主从架构</h2>
<ul>
<li>由HRegion和HMaster服务器构成，HMaster负责管理，所有的通信和协调由zookeeper处理.</li>
<li>HBase逻辑上的表被划分成多个HRegion，分别存储到HRegion服务器集群中。HMaster中存的是数据到Hregion的映射<br><img src="http://www.shenjixiang.cn/image/hbase/hbase体系结构.jpg" alt="hbase体系结构"></li>
<li>HRegion分为：HLOG（存储数据日志）和HRegion（实际数据）：很多store组成，每一个store存储一个列族。每一个store由多个storeFile组成，为hbase最小存储单元</li>
<li>数据的删除和更新均在合并的时候进行。采用追加的方式进行更新</li>
<li>HBase Master服务器（不存在单点故障，因为可以启动多个HMaster，通过zookeeper保证总有一个HMaster在运行）：管理对table的增删改查，管理Hregion服务器负载均衡，负责新HRegion的分配，迁移失效的HRegion服务器的HRegion</li>
</ul>
<h2 id="数据模型">数据模型</h2>
<ul>
<li>hbase中的数据都是字符串，采用稀疏存储</li>
<li>索引是行关键字、列关键字和时间戳</li>
<li>每一行都有一个可排序的主键和任意多的列，所以同一张表的每一行数据可以有不同的列</li>
<li>hbase的写操作都是琐行的，每一次更新都会使用时间戳来标记，Hbase会保留一定数量的版本</li>
<li>虽然每个表由很多行组成，但在物理存储上，是按照列来保存的</li>
<li>HBase表中的每个列都归属于某个列族，列族必须作为表模式(schema)定义的一部分预先给出，列名以列族作为前缀，每个“列族”都可以有多个列成员(column)，HBase把同一列族里面的数据存储在同一目录下，由几个文件保存。</li>
</ul>
]]></content>
        <pubTime>2014-09-03T15:00:15.000Z</pubTime>
        
         
              <breadCrumb title="HBase" url="http://www.shenjixiang.cn/tags/HBase/"/>
          
              <breadCrumb title="HBase" url="http://www.shenjixiang.cn/categories/HBase/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/01/18/extjs-2/</loc>
    <lastmod>2014-09-06T09:33:15.000Z</lastmod>
    <data>
        <display>
        <title>extJs_2</title>
        <content><![CDATA[<p>1.JS 类的声明,和对象的创建<br><code><br>function user()</code></p>
<p>//java 语言的public<br>this.Name = ‘uspcat’;<br>this.age = 26;<br>//var 就相对于高级语言当中的private<br>var email = “yfc@126.com”<br>this.getEmail = function(){<br>return email;<br>}</p>
<p>}</p>
<p>var u = new user();<br>alert(u.getEmail());</p>
<p>var person = {<br>name:’yfc’<br>,age:26<br>};<br>alert(person.name+” &nbsp;<wbr>“+person[‘age’]);</p>
<p>2.原始方法用EXTJS创建一个window窗口</p>
<p>var win = new Ext.window.Window({<br>width:400,<br>height:300,<br>title:’uspcat’<br>});<br>win.show();</p>
<p>3.利用一个按钮触发window窗体,了解一下EXTJS的事件机制</p>
<p>Ext.get(“myb”).on(“click”,function(){<br>win.show();<br>});</p>
<p>4.用EXTJS4.0的create来创建window</p>
<p>var win = Ext.create(‘Ext.window.Window’,{<br>width:400,<br>height:300,<br>title:’uspcat’<br>});<br>win.show();</p>
<p>利用Ext.create(‘’,{});来创建对象。</p>
<p>5.利用define自定义类并且集成(extend)window；</p>
<p>Ext.define(“ux.mywin”,{<br>extend:’Ext.window.Window’,<br>width:400,<br>height:300,<br>config: {<br>&nbsp;<wbr>&nbsp;<wbr> price: 500<br>},<br>newtitle: ‘new uspcat’,<br>mySetTitle:function(){<br>this.title = this.newtitle;<br>},<br>title:’uspcat’,<br><span style="line-height: 21px;">//初始化的方法</span><br>initComponent: function() {<br>this.mySetTitle();<br>this.callParent(arguments);<br>}<br>})</p>
<p>6.requires<br>&nbsp;<wbr>JS的异步加载，当需要的时候加载js。</p>
<p>Ext.Loader.setConfig({<br>enabled:true,<br>paths:{<br>&nbsp;<wbr> &nbsp;<wbr>//js路径<br>&nbsp;<wbr><br>&nbsp;<wbr>&nbsp;<wbr>myApp:’code/ux’<br>}<br>});</p>
<p>Ext.define(“ux.mywin”,{<br>extend:’Ext.window.Window’,<br>width:400,<br>height:300,<br><span style="line-height: 21px;">//config<br>自动生成的get和set方法</span><br>config: {<br>&nbsp;<wbr>&nbsp;<wbr> price: 500<br>},<br>newtitle: ‘new uspcat’,<br>mySetTitle:function(){<br>this.title = this.newtitle;<br>},<br>title:’uspcat’,<br>initComponent: function() {<br>this.mySetTitle();<br>this.callParent(arguments);<br>}<br>})</p>
<p>Ext.get(“myb”).on(“click”,function(){<br>var win = Ext.create(“ux.mywin”,{<br>title:’my win’,<br>price:600,<br>requires:[‘ux.mywin’]<br>});<br>win.show();<br>alert(win.getPrice());<br>});</p>
<p>7.mixins<br>类的混合（比继承强，可以实现多继承的功能）</p>
<p>Ext.define(“say”,{<br>cansay:function(){<br>alert(“hello”);<br>}<br>})</p>
<p>Ext.define(“sing”,{<br>sing:function(){<br>alert(“sing hello 123”);<br>},<br>})<br>Ext.define(‘user’,{<br>mixins :{<br>say : ‘say’,<br>sing: ‘sing’<br>}<br>});<br></p>
]]></content>
        <pubTime>2014-01-18T08:45:57.000Z</pubTime>
        
         
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/tags/extJs/"/>
          
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/categories/extJs/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/02/hbase-1/</loc>
    <lastmod>2014-09-03T14:57:26.000Z</lastmod>
    <data>
        <display>
        <title>了解hbase及完全分布式安装</title>
        <content><![CDATA[<h2 id="了解hbase">了解hbase</h2>
<ul>
<li>hbase是apache    hadoop的数据库，能够对大数据提供随机、实时的读写访问功能。具有开源、分布式、可扩展及面向列存储的特点。</li>
<li>hbase存储的是松散型数据，可以理解为key和value的映射关系，但它还有此外其他特性。</li>
<li>数据从逻辑上看像一张很大的表，并且数据列可以根据需要动态增加</li>
<li>向下提供存储，向上提供运算，将数据存储与并行计算完美的结合在一起</li>
</ul>
<h2 id="安装hbase">安装hbase</h2>
<ul>
<li>采用完全分布式安装，先决条件：hadoop、ssh。注意hbase与hadoop的版本对应，是否兼容</li>
<li>这里采用hbase-0.98.5-hadoop1-bin.tar.gz版本安装，每个节点都安装上</li>
<li>解压：加执行权限:chmod u+x hbase-0.98.5-hadoop1-bin.tar.gz ；tar -zxvf hbase-0.98.5-hadoop1-bin.tar.gz</li>
<li>将当前安装的hadoop的hadoop-core-x.jar和hadoop-test-x.jar复制到habase的lib目录替换其他版本hadoop</li>
<li>修改hbase.site.xml配置文件<img src="http://www.shenjixiang.cn/image/hbase/hbase-config-site.jpg" alt="hbase配置文件"></li>
<li>配置regionservers，每一行代表RegionServer服务器（我配置为；rh2，rh3）</li>
<li>每个HBase之间需要通过zookeeper通信，咱暂不安装，使用hbase自带的<br>— 在hbase-env.sh里设置export HBASE_MANAGES_ZK=true，表示使用自带zookeeper。设置为false则需配置hbase-site.xml里hbase.zookeeper.quorum的值<br>— 使用自带的对应进程为HQuorumPeer，相反为HQuorumPeerMain</li>
<li>启动：<br>—使用ssh拷贝数据到其他系统中：scp -r /usr/local/hbase0.98 rh2:/usr/local/<br>—启动顺序：hdfs—&gt;zookeeper(命令：zkServer.shstart)—&gt;hbase(命令：/usr/local/hbase0.98/bin/start-hbase.sh)<br>—如果有报错，看日志，注意jar包版本，一切以hadoop里的为准<br>—使用jps看看有没有HMaster和HQuorumPeer</li>
</ul>
<h2 id="hbase_shell">hbase shell</h2>
<ul>
<li>使用/usr/local/hbase0.98/bin/hbase shell命令进入shell</li>
<li><img src="http://www.shenjixiang.cn/image/hbase/hbase-shell.jpg" alt="hbase shell"></li>
</ul>
]]></content>
        <pubTime>2014-09-02T15:06:07.000Z</pubTime>
        
         
              <breadCrumb title="HBase" url="http://www.shenjixiang.cn/tags/HBase/"/>
          
              <breadCrumb title="HBase" url="http://www.shenjixiang.cn/categories/HBase/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/09/01/hive-2/</loc>
    <lastmod>2014-09-01T15:01:50.000Z</lastmod>
    <data>
        <display>
        <title>hive管理</title>
        <content><![CDATA[<h2 id="hive网络(web_ui)界面">hive网络(web ui)界面</h2>
<ul>
<li>目前0.13.x版本还未集成hive-hwi-0.13.x.war包，所以只有根据源码打个war包了。我用的是0.8.1的war包，照样跑。</li>
<li>在hive-site.xml里配置hvie主机地址和端口，还有war包的路径</li>
<li>输入hive —service hwi命令，仔细看看报错没。如果没报错，那就在浏览器输入刚配的hvie主机地址和端口就可以访问了(<a href="http://rh1:9999/hwi/)。这对新手来说是非常有帮助的。" target="_blank" rel="external">http://rh1:9999/hwi/)。这对新手来说是非常有帮助的。</a></li>
<li>弄好之后就可以查看数据库，创建会话、查询等等了。注意会话在hive重启之后将全部丢失。会话与认证(antorize)是关联的，一旦创建将不可改变。</li>
</ul>
<h2 id="hive的JDBC接口使用">hive的JDBC接口使用</h2>
<ol>
<li>eclipse环境搭建<br>— 创建java project，添加如下jar包：<br><img src="http://www.shenjixiang.cn/image/hive/hive_lib.jpg" alt="jar包"><br>— 首先开启hive监听用户的连接，执行(两个横线)hive —service hiveserver ;之后就可以开始编写hive程序了</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加载驱动</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line"><span class="keyword">Class</span>.forName(<span class="string">"org.apache.hadoop.hive.jdbc.HiveDriver"</span>);</div><div class="line"></div><div class="line"><span class="comment">//创建连接</span></div><div class="line">Connection con = DriverManager.getConnection(<span class="string">"jdbc:hive://rh1:10000/default"</span>, <span class="string">""</span>, <span class="string">""</span>);</div><div class="line"></div><div class="line">Statement state = con.createStatement();</div><div class="line">ResultSet res=state.executeQuery(<span class="string">"create table t_test(userid int,username string)row format delimited "</span> +</div><div class="line"><span class="string">"fields terminated by '\t' stored as textfile"</span>);</div><div class="line"><span class="keyword">if</span>(res.<span class="keyword">next</span>()){</div><div class="line">	System.out.<span class="keyword">println</span>(res.getString(<span class="number">1</span>));</div><div class="line">}</div><div class="line"></div><div class="line">String showTables =<span class="string">"show tables"</span>;</div><div class="line">ResultSet res2 = state.executeQuery(showTables);</div><div class="line"><span class="keyword">if</span>(res2.<span class="keyword">next</span>()){</div><div class="line">	System.out.<span class="keyword">println</span>(res2.getString(<span class="number">1</span>));</div><div class="line">}</div><div class="line"></div><div class="line">} <span class="keyword">catch</span> (Exception e) {</div><div class="line">	e.printStackTrace();</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="hive的优化">hive的优化</h2>
<ol>
<li>优化主要在查询时，列裁剪(只查询需要的列)，需设置hive.optimize.cp=true</li>
<li>分区裁剪：查询不必要的分区，在where后加分区目录名。例如：select * from t_data where part = 100;这样就只会查询t_data目录下part=100目录的数据</li>
<li>join：在join是尽量将数据少的表放在join左边，这样可以减少内存溢出的风险</li>
<li>map join：前提是在map端时可以加载到全部需要的数据</li>
<li>group by：<br>—map端部分聚合：需设定hive.map.aggr=true,hive.groupby.mapaggr.checkinterval=100000，用于设定map端聚合条数<br>—数据倾斜：数据分布不均，需进行负载均衡。设定hive.groupby.skewindata=true</li>
<li>合并小文件：设置合并map端输出的文件，hive.merge.mapfiles=true。设置合并reduce端输出的文件，hive.merge.mapredfiles=true。设定合并文件大小：hive.merge.size.per.task=256乘以1000乘以1000(默认)</li>
</ol>
]]></content>
        <pubTime>2014-09-01T13:25:14.000Z</pubTime>
        
         
              <breadCrumb title="hive" url="http://www.shenjixiang.cn/tags/hive/"/>
          
              <breadCrumb title="hive" url="http://www.shenjixiang.cn/categories/hive/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/08/31/hive-1/</loc>
    <lastmod>2014-08-31T14:27:50.000Z</lastmod>
    <data>
        <display>
        <title>初识hive及安装</title>
        <content><![CDATA[<h2 id="了解Hive">了解Hive</h2>
<ul>
<li>Hive是一个基于hadoop文件系统之上的数据仓库架构</li>
<li>提供数据ETL（抽取、转化和加载）工具、数据存储管理和大型数据集的查询和分析</li>
<li>支持类似SQL的语句，不提供排序和查询缓存，不提供在线事物处理和实时的查询和记录级的更新，只能处理不变的大数据集</li>
<li>将外部命令解析成MapRecude计划，交给集群处理</li>
</ul>
<h2 id="Hive的数据存储">Hive的数据存储</h2>
<ul>
<li>建立在hdfs上，没有专门的格式，没有索引，只需要建表时告诉hive列分隔符和行分隔符就可以解析数据了</li>
<li>主要四类数据模型：<br>— 表：Hive中的表和关系型数据库中的表在概念上很类似，每个表在HDFS中都有相应的目录用来存储表的数据，表名即目录名<br>— 外部表：Hive中的外部表和表很类似，而是数据存放到别处，删除外部表只会删除元数据，数据不会被删除的；而删除表，该表对应的所有数据包括元数据都会被删除<br>— 分区：就是表下面的子目录，分区位于表的目录下。相当于简单的索引功能,分区名不能与字段名重复<br>— 桶：对指定的列计算其hash，根据hash值切分数据，相同hash值的存一个文件里，一个桶对应一个文件。分区下面也是可以建立桶的。</li>
</ul>
<h2 id="安装Hive">安装Hive</h2>
<ol>
<li>安装好hadoop</li>
<li>下载hive [<a href="http://apache.fayea.com/apache-mirror/hive/" target="_blank" rel="external">http://apache.fayea.com/apache-mirror/hive/</a>]</li>
<li>装在/usr/local/下 解压：加执行权限:chmod u+x apache-hive-0.13.1-bin.tar.gz  执行tar -zxvf apache-hive-0.13.1-bin.tar.gz</li>
<li>配置环境变量：vi    /etc/profile 添加<br>— export HIVE_HOME=/usr/local/hive0.13<br>— export PATH=$HIVE_HOME/bin:$HIVE_HOME/conf</li>
<li>配置Hive ：<br>—默认没有hive-site.xml 手动创建 cp hive-default.xml.template hive-site.xml<br>—修改hive-site.xml：<ul>
<li>hive.metastore.warehouse.dir  指定hive的数据存储目录（为hdfs上的位置）</li>
<li>hive.exec.scratchdir  指定hive数据临时文件目录</li>
<li>连接数据库配置：hive需要将元数据存储在RDBMS中，相当重要的。默认使用Derby数据库。<br>这里修改为MySql，配置如下：<ul>
<li>这里MySQL采用rpm包安装</li>
<li>rpm -qa|grep -i mysql  #查看已经安装的mysql相关包,如果系统自带有的话最好卸载掉</li>
<li>rpm -ev package_name #package_name包名 比如：mysql-server-5.0.51b-1.el5<br>卸载后/var/lib/mysql中的/etc/my.cnf会重命名为my.cnf.rpmsave，/var/log/mysqld.log 会重命名为/var/log/mysqld.log.rpmsave，如果确定没用后就手工删除</li>
<li>运行 rpm -ivh mysql-server-5.5.rpm —nodeps</li>
<li>运行 rpm -ivh mysql-client-5.5.rpm —nodeps</li>
<li>启动 /etc/init.d/mysql start 或 service mysql start</li>
<li>停止 /etc/init.d/mysql stop 或 service mysql stop</li>
<li>自动启动：察看mysql是否在自动启动列表中 /sbin/chkconfig —list<br>把MySQL添加到你系统的启动服务组里面去 /sbin/chkconfig —add mysql<br>把MySQL从启动服务组里面删除 /sbin/chkconfig —del mysql 查看服务状态：service mysql status</li>
<li>修改密码 /usr/bin/mysqladmin -u root password ‘new-password’</li>
<li>配置：将/usr/share/mysql/my-medium.cnf复制到/etc/my.cnf，以后修改my.cnf文件来修改mysql的全局设置<br>将my.cnf文件中的innodb_flush_log_at_trx_commit设成0来优化[mysqld]后添加添加lower_case_table_names设成1来不区分表名的大小写</li>
<li>安装好mysql后，就是配置hive-site.xml里的连接字符串、驱动、用户名密码</li>
<li>将mysql驱动包放入hive安装目录lib里</li>
</ul>
</li>
</ul>
</li>
<li>启动hive：输入hive启动</li>
</ol>
<h2 id="配置Hive">配置Hive</h2>
<ul>
<li>可通过hive-site.xml配置</li>
<li><p>运行时配置：</p>
<ul>
<li>set -v; 查看当前设定信息（set为session级的，所有set操作只对本次操作有效）</li>
<li>等等…</li>
</ul>
</li>
<li><p>hive建表，建分区、函数等等命令这里就不多讲了，都是死的，没意义，用到的时候百度就行了。</p>
</li>
</ul>
]]></content>
        <pubTime>2014-08-31T10:18:56.000Z</pubTime>
        
         
              <breadCrumb title="hive" url="http://www.shenjixiang.cn/tags/hive/"/>
          
              <breadCrumb title="hive" url="http://www.shenjixiang.cn/categories/hive/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/08/24/hadoop-6/</loc>
    <lastmod>2014-08-24T14:16:31.000Z</lastmod>
    <data>
        <display>
        <title>hadoop进阶之管理</title>
        <content><![CDATA[<h2 id="了解hdfs文件结构">了解hdfs文件结构</h2>
<h4 id="1-_NameNode的文件结构：初始化dfs的时候会产生以下目录文件">1. NameNode的文件结构：初始化dfs的时候会产生以下目录文件</h4>
<ul>
<li>${dfs.name.dir}/current/VERSION<br>-包含java属性文件，hdfs版本信息<br>-重点说一下namespaceID，第一次格式化的时候便会创建。各个DataNode节点和此处的必须一样，否者不可用。如果NameNode进行二次格式化，会导致DataNode与NameNode不一致，所以要手动改成一致的。<br>以下三个都是二进制文件可进行序列化后查看</li>
<li>${dfs.name.dir}/current/edits<br>-是编辑日志，会在写文件时记录该操作</li>
<li>${dfs.name.dir}/current/fsimage<br>-存储文件系统目录和文件inodes(表示文件或目录的元数据信息，文件副本数，修改和访问时间)</li>
<li>${dfs.name.dir}/current/fstime</li>
</ul>
<h4 id="2-_Secondary_NameNode">2. Secondary NameNode</h4>
<ul>
<li>任务就是辅助NameNode处理fsimage和编辑日志的节点，从NameNode中复制fsimage和编辑日志（执行里面的操作）并定期合并生成一个新的fsimage，后传给NameNode。</li>
<li>目录结构和NameNode一样</li>
</ul>
<h4 id="3-_DataNode的文件结构">3. DataNode的文件结构</h4>
<ul>
<li>${dfs.data.dir}/current/VERSION</li>
<li>${dfs.data.dir}/current/blk…</li>
<li>当目录中存储的块数达到一定数量时（由dfs.DataNode.numblocks属性设置），DataNode会创建一个新的目录来保存新的块数据</li>
</ul>
<h2 id="hadoop管理命令">hadoop管理命令</h2>
<ul>
<li>hadoop dfsadmin（需超级用户权限），有以下命令选项<br>-report ：报告文件系统的基本信息<br>-safemode enter|leave|get|wait ：进入安全模式<br>-refreshNodes ：NameNode重新识别新的节点和退出集群的节点<br>-hadoop fsck / ：文件系统验证，是否存在丢失的块，副本数是否达到要求<br>-等等….<br>-hadoop fsck /output/hello.txt -files -blocks -racks ：找到某个文件的所有块<br>-start-balancer.sh命令均衡文件系统</li>
</ul>
<h2 id="hadoop节点的管理">hadoop节点的管理</h2>
<ul>
<li>一般来说新增一个节点修改一下配置文件就可以了，但是还是最好配置一个授权节点列表来管理</li>
<li>例如节点的新增，删除，升级操作请百度</li>
</ul>
]]></content>
        <pubTime>2014-08-24T12:27:30.000Z</pubTime>
        
         
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/tags/hadoop/"/>
          
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/categories/hadoop/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/08/23/hadoop-5/</loc>
    <lastmod>2014-08-23T06:52:05.000Z</lastmod>
    <data>
        <display>
        <title>使用HDFS Java api操作dfs</title>
        <content><![CDATA[<h2 id="从本地上传到hdfs文件系统中:">从本地上传到hdfs文件系统中:</h2>
<p>代码如何运行：右键Run Configurations，选Arguments填上输入的数据就对了。空格隔开。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"><span class="keyword">import</span> java.io.BufferedInputStream;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> java.io.FileInputStream;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> java.io.InputStream;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> java.io.OutputStream;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> java.net.URI;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> org.apache.hadoop.io.IOUtils;</span></div><div class="line"><span class="preprocessor"><span class="keyword">import</span> org.apache.hadoop.util.Progressable;</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fileSystem</span> </span>{</div><div class="line"></div><div class="line"><span class="comment">// 从本地上传到hdfs文件系统中</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {</div><div class="line">	InputStream <span class="keyword">in</span> = <span class="literal">null</span>;</div><div class="line">	<span class="keyword">try</span> {</div><div class="line">		String localSrc = args[<span class="number">0</span>];</div><div class="line">		String dst = args[<span class="number">1</span>];</div><div class="line">		<span class="keyword">in</span> = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(localSrc));</div><div class="line">		Configuration conf = <span class="keyword">new</span> Configuration();</div><div class="line">		FileSystem fs = FileSystem.<span class="keyword">get</span>(URI.create(dst), conf);<span class="comment">//对hdfs操作基本使用FileSystem就已足够</span></div><div class="line">		OutputStream out = fs.create(<span class="keyword">new</span> Path(dst), <span class="keyword">new</span> Progressable() {</div><div class="line">		@Override</div><div class="line">		<span class="keyword">public</span> <span class="keyword">void</span> progress() {<span class="comment">//回调，显示文件输出速度,每写入64kb输出一个星</span></div><div class="line">			System.out.print(<span class="string">"*"</span>);</div><div class="line">		}</div><div class="line">		});</div><div class="line">		IOUtils.copyBytes(<span class="keyword">in</span>, out, <span class="number">4096</span>, <span class="literal">false</span>);</div><div class="line">	} <span class="keyword">catch</span> (Exception e) {</div><div class="line">		e.printStackTrace();</div><div class="line">	} <span class="keyword">finally</span> {</div><div class="line">		IOUtils.closeStream(<span class="keyword">in</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="文件系统查询">文件系统查询</h2>
<ul>
<li>可查询系统的元数据信息和文件的目录结构,长度，块大小、副本、修改时间等等信息</li>
<li>文件元数据: FileStatus对象，针对一个文件的一些信息。多个文件采用数组。<br> //测试列出每个文件的信息,只会列出当前的目录，如果还有下一集的话，通常采用递归来操作。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Path</span>[] paths = new <span class="keyword">Path</span>[<span class="number">1</span>];</div><div class="line">paths[<span class="number">0</span>] = new <span class="keyword">Path</span>(args[<span class="number">2</span>]);</div><div class="line">FileStatus[] status = fs.listStatus(paths);</div><div class="line"><span class="keyword">Path</span>[] listedPaths =FileUtil.stat2Paths(status);</div><div class="line">for (<span class="keyword">Path</span> path : listedPaths) <span class="list">{</span></div><div class="line">	System.out.println(path);</div><div class="line">}</div><div class="line">//通过通配符筛选文件,复杂文件则采用PathFilter进行再次过滤</div><div class="line">status = fs.globStatus(new <span class="keyword">Path</span>(<span class="string">"hdfs://rh1:9000/output/*"</span>));</div></pre></td></tr></table></figure>

<h2 id="文件归档">文件归档</h2>
<ul>
<li>文件归档命令：hadoop archives -archiveName file.har -p /output/ /out/<br>这步的操作时将/output/目录文件归档到/out/的file.har文件里。</li>
<li>har是一个文件系统，其实是一个目录，那么删除就需要递归删除。<br>删除：haoop fs -rmr /out/file.har </li>
<li>递归查看har文件：hadoop fs -lsr har:///out/file.har</li>
<li><p>不足：目前没有针对har文件的压缩方法，不能修改har文件里的内容。<br>虽然可以将小文件打成一个大文件作为MapReduce的输入，但是没有一个基于归档的InputFormat可以将多个文件打包到一个单一的MapReduce中区。<br>所以，即使是har文件，处理小的文件是效率依然不高。</p>
</li>
<li><p>还可以通过WebHDFS操作hdfs，具体操作这里就不讲了。</p>
</li>
</ul>
]]></content>
        <pubTime>2014-08-23T06:40:38.000Z</pubTime>
        
         
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/tags/hadoop/"/>
          
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/categories/hadoop/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/08/21/hadoop-4/</loc>
    <lastmod>2014-08-23T06:45:44.000Z</lastmod>
    <data>
        <display>
        <title>HDFS分布式文件系统</title>
        <content><![CDATA[<h2 id="NameNode:">NameNode:</h2>
<ul>
<li>HDFS的守护程序</li>
<li>记录文件是如何分割成数据块的，以及这些数据块被存到哪些节点的，分别是命名空间镜像(Namespace image)和编辑日志(Edit log)这两个文件，重启时动态重建这些文件。</li>
<li>对内存和I/O进行集中管理。</li>
<li>是单个节点，发生故障是集群崩溃(可以同步备份元数据文件到其他机架上)。</li>
</ul>
<h2 id="Secondary_Namenode：（辅助名称节点）">Secondary Namenode：（辅助名称节点）</h2>
<ul>
<li>监控HDFS状态的辅助后台程序。</li>
<li>每个集群都有一个。</li>
<li>作为NameNode备用使用，只能手动启动。</li>
<li>可以作为冷备份</li>
<li>工作是帮助NN合并edits log,减少NN启动时间。</li>
</ul>
<h2 id="DataNode：每台服务器都运行一个">DataNode：每台服务器都运行一个</h2>
<ul>
<li>负责把HDFS数据块读写到本地文件系统。文件以块存储</li>
<li>datanode在存储数据时，如果原始文件大小&gt;64MB,按照64MB大小切分；如果&lt;64MB，</li>
<li>只有一个block，占用磁盘空间是源文件实际大小。block上传后大小不可变（修改）。</li>
<li>Block副本放置策略：第一个副本放在当前上传文件的DN，第二个放在与第一个不同的机架节点上。第三个与第二个不同的节点上。</li>
<li>HDFS文件权限：read:r, w:write ,x:execute</li>
<li>通过心跳定时向NameNode发送所存储的文件块信息。</li>
</ul>
<h2 id="安全模式：">安全模式：</h2>
<ul>
<li>用户只可读，不可写，删，重命名。</li>
<li>NameNode检查每个数据块的副本数是否达到要求的最小值，检查完后，在一个特定的时间退出安全模式，将没达到最小副本的数据块进行复制。</li>
</ul>
<h2 id="HDFS命令：">HDFS命令：</h2>
<ul>
<li>对hdfs的操作方式：hadoop fs xxx</li>
<li>hadoop fs -ls  /    查看hdfs的根目录下的内容的</li>
<li>hadoop fs -lsr /    递归查看hdfs的根目录下的内容的</li>
<li>hadoop fs -mkdir /d1    在hdfs上创建文件夹d1</li>
<li>hadoop fs -put <linux source=""> <hdfs destination=""> 把数据从linux上传到hdfs的特定路径中</hdfs></linux></li>
<li>hadoop fs -get <hdfs source=""> <linux destination=""> 把数据从hdfs下载到linux的特定路径下</linux></hdfs></li>
<li>hadoop fs -text <hdfs文件>    查看hdfs中的文件</hdfs文件></li>
<li>hadoop fs -rm        删除hdfs中文件</li>
<li>hadoop fs -rmr    删除hdfs中的文件夹</li>
<li>hadoop fs -ls hdfs://hadoop0:9000/</li>
<li>hadoop job -list #列出正在运行的job</li>
<li>hadoop job -kill <job_id>  #kill job</job_id></li>
<li>hadoop fsck #检查HDFS块状态，是否损坏</li>
<li>hadoop fsck /-delete #检查HDFS块状态，删除损坏块。</li>
<li>hadoop dfsadmin -report #检查hdfs状态，包括DN信息</li>
<li>hadoop dfsadmin -safemode enter|leave #进入或离开安全模式</li>
<li>hadoop distcp hdfs:a:8020/xxxx hdfs:b:8020/xxxx 并行copy</li>
<li>./bin/start-balancer.sh #平衡集群文件</li>
<li>hadoop jar 文件路径 &lt;传入&gt; &lt;传出&gt; #执行jar</li>
</ul>
]]></content>
        <pubTime>2014-08-21T12:03:17.000Z</pubTime>
        
         
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/tags/hadoop/"/>
          
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/categories/hadoop/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/08/13/hadoop-2/</loc>
    <lastmod>2014-08-21T12:10:37.000Z</lastmod>
    <data>
        <display>
        <title>hadoop MapReduce编写</title>
        <content><![CDATA[<h2 id="安装ecilpse_hadoop插件：">安装ecilpse hadoop插件：</h2>
<ol>
<li>下载hadoop-eclipse-plugin-1.1.2.jar放在eclipse plugins下.</li>
<li>进入eclipse 打开window—&gt;preferences里配置hadoop Map/Reduce里hadoop的安装路径（就是hadoop解压后的文件目录，最后要的其实是jar包）</li>
<li>如果在window里远程调用haodop集群编程，那么需重新编译hadoop解压后根目录的hadoop-core-1.1.2.jar（注释掉checkReturnValue方法），网上一般有人编译好的。</li>
<li>打开 Map/Reduce Locations这个窗口，新建一个连接就可以连接dfs了。<br>（注意端口：Map/Reduce Master为：config/mapred-site.xml里的mapred.job.tracker的值，DFS Master:为config/core-site.xml里fs.default.name的值）。</li>
<li>注意必须将config/hdfs-site.xml/里dfs.permissions设置为false才能够连接上。（如遇其他问题，请百度）</li>
<li>新建一个map/reduce项目，放入hadoop自带的wordcount就可以运行了。</li>
</ol>
<h2 id="了解MapReduce：">了解MapReduce：</h2>
<ol>
<li>MapReduce:编程模型，主要用来做数据分析.<br>执行流程：<br>用户程序代码<br>——》Inputformat(默认TextInputformat，针对文本文件。作用：分解数据，切分成小数据集InputSplit<key,value>,key:行在文本中的位置，value:每一行的数据,一个InputSplit由一个mapper处理)<br>——》map（自己编写的程序代码）<br>——》（combine）（map段合并，减少机架间数据的传输）<br>——》partition(Mapper最终处理的键值对<key, value="">，是需要送到Reducer去合并的，合并的时候，<br>有相同key的键/值对会送到同一个Reducer那。哪个key到哪个Reducer的分配过程，是由Partitioner规定的。它只有一个方法(getPartition(Text key, Text value, int numPartitions))<br>输入是Map的结果对<key, value="">和Reducer的数目，输出则是分配的Reducer（整数编号）。<br>就是指定Mappr输出的键值对到哪一个reducer上去。<br>系统缺省的Partitioner是HashPartitioner，它以key的Hash值对Reducer的数目取模，得到对应的Reducer。<br>这样保证如果有相同的key值，肯定被分配到同一个reducre上。如果有N个reducer，编号就为0,1,2,3……(N-1)。)<br>——》copy&amp;merge<br>——》sort<br>——》reduce（如果没自定义partition，默认相同key的会被送到一个reduce上）——》outputformat（输出）</key,></key,></key,value></li>
<li>复杂的map,reduce函数<br>MapReduce分为：map和reduce，那么分别对应map task和reduce task，一般我们自己写的map类继承Mapper类，重写map方法来编写我们对数据的处理，数据格式为<key,value>,key为当前这行数据在文本中的偏移量，value为当前这一行的数据。<br>一般我们重写Mapper类的map方法，特殊需要可重写setup(task启动之前调用，可以设置一些全局变量，初始化，监控task启动),<br>cleanup(task结束之前调用),run(真正调用map的方法)方法.</key,value></li>
<li><p>MapReduce job中共享全局变量<br>由于map和reduce都是相对独立的，并且是跨jvm的，所以通过代码级别的共享是不能过做的。以下提供几种方法：<br>第一种：读取hdfs文件，可以事先约定好一个文件，都去读取，来时变量共享。这样变量即可读也可写，但需注意并发写的时候。但这样无疑增加了I/O操作。<br>第二种：设置job属性,通过config.set(“myName”, “shenjixiang”);//在config中设置全局变量。<br>config.get(“myName”);//取得在config中设置的全局变量。这种在小数据可行且消耗资源小，但大数据量就有点乏力了。<br>第三种：使用DistributedCache(是mapreduce为mapreduce提供的缓存文件的只读工具)，可以缓存文本文件、压缩文件和jar文件等。</p>
</li>
<li><p>hadoop job Scheduler:<br>hadoop默认的调度器是基于队列的fifo调度器。<br>所有用户的作业都被提交到一个队列中，jobtracker按照先后优先级高低，再按照提交时间先后执行。<br>优点：调度算法简单明了，jobtrscker工作负担轻。<br>缺点：忽略了不同作业的需求差异。<br>hadoop有自己的io机制，io类都必须实现Wridtable接口.</p>
</li>
<li><p>jobTracker失败：很严重。用zookeeper来协作JobTracker<br>taskTracker失败：由于崩溃或运行过于缓慢，它会向JobTracker发送心跳<br>如果有未完成的作业，JobTracker会重新把这些任务分配给其他taskTracker.<br>即使taskTracker没有失败也可以被JobTracker列入黑名单。</p>
</li>
</ol>
<h2 id="MapReduce作业调优：">MapReduce作业调优：</h2>
<ol>
<li>Mapreduce:在执行mapreduce之前，原数据将被分割成多个split,<br>每个split作为一个map任务的输入，在map执行过程中split会被分解成一个个记录(key-value对)，map会依次处理每一个记录。<br>一个1G的文件，会被分成16个64M的split并分配16个map任务处理。而1000个100kb的文件会被1000个map处理。自定义输入格式：继承FileInputFormat,重写isSplitable(。。)</li>
<li>重写getRecordReader()方法。输出：MultipleOutputFormat（一个reduce产生多个输出，用的多）TextOutputFormat：默认的输出（用的多）。</li>
<li><p>小文件优化解决：<br>小文件合并、hadoop本身提共的压缩（gzip(用的多),bzip2,lzo(用的多)）<br>jvm重用   方法：开启jvm重用<br>mapred.reduce.parallel.copies    方法：默认5，修改20 </p>
</li>
<li><p>mapper的数量：尽量将输入数据切分成数据块的整数倍。<br>如有太多小文件，则考虑CombineFileInputFormat</p>
</li>
<li>redudcer的数量：集群中reducer数应该略小于reducer的任务数</li>
<li>combiner:充分使用合并函数减少map和reduce之间传递的数据量，combiner在map后运行。</li>
<li>中间值的压缩：conf.setCompressMapOutput(true)和setMapOutputCompressorClass(GzipCodec.class)</li>
<li>自定义序列：如果使用自定义的Writable对象或自定义的comparator,则必须确保已实现RawComparator.</li>
</ol>
]]></content>
        <pubTime>2014-08-13T14:27:19.000Z</pubTime>
        
         
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/tags/hadoop/"/>
          
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/categories/hadoop/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/08/19/hadoop-3/</loc>
    <lastmod>2014-08-21T12:08:11.000Z</lastmod>
    <data>
        <display>
        <title>第二代 MapReduce(Yarn)</title>
        <content><![CDATA[<h2 id="由于1-0版本框架的局限性，">由于1.0版本框架的局限性，</h2>
<p>比如：</p>
<ul>
<li>jobTracker单点问题。</li>
<li>TaskTracker端，由于作业分配信息过于简单，有可能将多个资源或运行时间长的Task分配到同一个节点上，这样会造成作业的单点失败或等待时间过长。</li>
<li>作业延迟过高。在mapReduce运行之前，需要tasktracker汇报自己的情况，jobtracker再分配任务，这一过程明显会造成运行延迟。</li>
</ul>
<h2 id="Yarn:">Yarn:</h2>
<ul>
<li>可靠性,扩展性,兼容MR1,演化（使用户能够控制集群中软件的升级）,可预测延迟（提高小作业的反应和处理速度）,集群利用率(比如Map Task和Reduce Task的资源共享等),支持除MapReduce框架外的其他框架,支持受限和短期的服务。</li>
</ul>
<h2 id="Yarn主要架构：">Yarn主要架构：</h2>
<ul>
<li>将JobTracker承担的两大块任务，集群资源管理(由全局的资源管理器管理)和作业管理进行分离(由针对每个作业的应用主体管理)，让TaskTracker变成节点管理器。</li>
</ul>
<h2 id="资源管理器：">资源管理器：</h2>
<ul>
<li>分为调度器和应用管理器，调度器只负责根据集群中的容量、队列和资源等限制分配资源，不负责任务失败的处理。</li>
<li>应用管理器则负责接收作业，并获取一个资源容器用于作业和重启失败的应用。</li>
</ul>
<h2 id="节点管理器：">节点管理器：</h2>
<ul>
<li>是每个节点的框架代理。负责启动应用的容器，监控容器的资源使用，并把这些信息上报给调度器。</li>
<li>集群每个节点都有一个节点管理器，负责：<br>— 启动调度器分配的容器。<br>— 保证已启用的容器不会使用超过分配的资源量。<br>— 为task搭建容器环境,一些二进制文件，jars等等。<br>— 为当前节点提供一个管理本地资源的简单服务。</li>
</ul>
<h2 id="应用主体:">应用主体:</h2>
<ul>
<li>应用主体与应用一一对应</li>
<li>与调度器协商资源</li>
<li>与节点管理器合作，在合适的容器中运行对应的组件task,并监控task的执行。</li>
<li>如果容器出现故障，应用主体会向调度器申请资源</li>
<li>计算应用所需的资源量，并转化为调度器可识别的协议包。</li>
<li>应用主体出现故障后，应用管理器会负责重启它，但是需要由应用主体自己从以前保存的执行状态中回复应用。</li>
</ul>
<h2 id="Yarn的优势：">Yarn的优势：</h2>
<ul>
<li>分散了JobTracker的任务。资源管理任务由资源管理器负责，作业的启动、运行和监控由分布在集群节点上的应用主体负责。这样减少了JobTracker的单点瓶颈和风险，提高了可用性和扩展性。</li>
<li>应用主体可自己编写，适用范围增大。</li>
<li>资源管理器上使用ZooKeeper实现故障转移。当资源管理器故障时，备用资源管理器将根据保存在ZooKeeper中的集群状态快速启动。Yarn支持应用程序指定检查点。这样就可以保证应用主体失败后能快速根据HDFS上保存的状态重启。</li>
<li>集群资源统一组织成资源容器，提高了资源的利用率。</li>
</ul>
]]></content>
        <pubTime>2014-08-19T13:53:31.000Z</pubTime>
        
         
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/tags/hadoop/"/>
          
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/categories/hadoop/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/08/10/hadoop-1/</loc>
    <lastmod>2014-08-19T14:03:14.000Z</lastmod>
    <data>
        <display>
        <title>hadoop伪分布式安装</title>
        <content><![CDATA[<h2 id="步骤如下：">步骤如下：</h2>
<p>在虚拟机安装完后需要做一下操作：</p>
<ol>
<li><p>关闭防火墙<br>重启后永久性生效：<br>开启自动运行：chkconfig iptables on<br>关闭自动运行：chkconfig iptables off<br>验证：service iptables status<br>执行chkconfig —list | grep iptables</p>
</li>
<li><p>修改静态ip<br>执行service network restart重启网络服务</p>
</li>
<li><p>修改hostname<br>执行vi /etc/sysconfig/network<br>NETWORKING=yes<br>HOSTNAME=yourname //在这修改hostname<br>修改/etc/hosts里面的名字<br>执行vi /etc/hosts<br>127.0.0.1 localhost.localdomain localhost<br>172.17.33.169 yourname //在这修改hostname<br>重启生效</p>
</li>
<li><p>设置ssh自动登录(远程登录的时候用,默认找authorized_keys文件)<br>执行ssh-keygen -t rsa 一直回车（存于当前用户的.ssh目录下）<br>执行cp .ssh/id_rsa.pub .ssh/authorized_keys<br>执行scp .ssh/authorized_keys rh2:.ssh/authorized_keys<br>后将authorized_keys文件给对方即可执行ssh rh2远程登录</p>
</li>
<li><p>安装jdk1.6<br>装在/usr/local/下<br>rm -rf /usr/local/* 删除所有内容<br>解压：加执行权限:chmod u+x jdk1.6-i586.bin<br>./jdk1.6-i586.bin<br>重命名：mv jdk1.6-i586 jdk1.6<br>配置: vi /etc/profile<br>在上面加入:export JAVA_HOME=/usr/local/jdk1.6<br>export PATH=.:$JAVA_HOME/bin:$PATH<br>保存退出<br>执行 source /etc/profile 让文件立即生效<br>验证:java -version</p>
</li>
<li><p>安装hadoop（版本号：1.1.2）<br>装在/usr/local/下<br>解压：加执行权限:chmod u+x hadoop-1.1.2.tar<br>tar -zxvf hadoop-1.1.2.tar<br>配置: vi /etc/profile<br>在上面加入:export JAVA_HADOOP=/usr/local/hadoop1.1.2<br>修改export PATH=.:$HADOOP_HOME/bin:$JAVA_HOME/bin:$PATH<br>保存退出<br>执行 source /etc/profile 让文件立即生效<br>接下来就是配置hadoop了。<br>编辑conf/hadoop-env.sh<br>编辑conf/core-site.xml,hdfs-site.xml,mapred-site.xml三个核心配置文件<br>配置ssh，生成密钥，使ssh可以免密码连接localhost<br>格式化HDFS:hadoop namenode -format<br>使用/usr/local/hadoop1.1.2/bin/start-all.sh启动Hadoop 使用命令jps查看启动的进程<br>使用/usr/local/hadoop1.1.2/bin/stop-all.sh关闭Hadoop</p>
</li>
</ol>
]]></content>
        <pubTime>2014-08-10T14:19:59.000Z</pubTime>
        
         
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/tags/hadoop/"/>
          
              <breadCrumb title="hadoop" url="http://www.shenjixiang.cn/categories/hadoop/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/01/17/extjs-start/</loc>
    <lastmod>2014-06-20T10:12:56.000Z</lastmod>
    <data>
        <display>
        <title>ExtJs安装</title>
        <content><![CDATA[<h2 id="_"> </h2>
<p>Eclipse中安装Extjs插件（Spket IDE）</p>
<p>Spket IDE是目前支持Ext<br>2.0最为出色的IDE。官方网站<a href="http://www.spket.com/" target="_blank" rel="external">http://www.spket.com</a>。 它采用.jsb project<br>file 文件并将继承于基类和所有文档的内容嵌入到生成代码提示的Script. doc中。</p>
<p>由于Spket只是一个单纯的编辑器，没有其它格式的支持（如CSS），所以我的做法是用它的Eclipse插件形式，当然也可以单独安装它作为编辑JS的工具。</p>
<p>作为Eclipse的插件安装很简单，下载spket-1.6.18-lience，.rar解压放在eclipse对应位置，重启，ok。</p>
<p>安装完后在eclipse中进行设置：</p>
<p>Window → Preferences → Spket<br>→ JavaScript. Profiles → New ；</p>
<p>输入“ExtJS”点击OK；</p>
<p>选择“ExtJS” 并点击“Add Library”然后在下拉条中选取“ExtJS”；</p>
<p>选择 “ExtJS”并点击“Add File”，然后在你的./ext-2.x/source目录中选取“ext.jsb” 文件；</p>
<p>选择你想加载的插件</p>
<p>设置新的ExtJS Profile，选中并点击“JavaScript. Profiles”<br>对话框右手边的“Defalut”按钮；</p>
<p>JS打开方式为 Window → Preferences<br>→ General→ Editors→ File…</p>
<p>选择JS 或者新创建 设置默认打开方式 为 Spket<br>JavaScript. Editor(default)</p>
<p>OK本人已经成功使用MYECLIPSE2013，打开你的JS吧。尽情的Ext点点点点吧！！属性支持类似JAVA类，声明后才可以获得属性，Spket<br>还封装了JS常用函数。EXT编写环境已经捆饶以久，可是说Spket+EXT是最完美的编写EXT环境。</p>
]]></content>
        <pubTime>2014-01-17T14:18:24.000Z</pubTime>
        
         
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/tags/extJs/"/>
          
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/categories/extJs/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/30/jdbc-oracle/</loc>
    <lastmod>2014-06-20T10:11:45.000Z</lastmod>
    <data>
        <display>
        <title> jdbc连接oracle</title>
        <content><![CDATA[<p>jdbc连接oracle其实跟连接mysql区别不大。基本步骤一样<br>1.加载驱动<br>2.创建连接<br>3.获得sql语句对象<br>4.执行语句<br>5.处理结果<br>6.关闭连接<br>这里给大家列了具体分了两种： statement 每次都有执行<br>prepareStatement 执行一次,CallableStatement 调用orale里的过程，函数等。<br>一：执行基本的sql语句<br><code><br>public PreparedStatement prep = null;<br>public ResultSet res = null;<br>String sql = “ select count(*)from emp”;<br>prep =con.prepareStatement(sql);<br>  //<br>4.执行<br> res =<br>prep.executeQuery();<br> while (res.next()) {<br>System.out.println(res.getInt(1));</code></p>
<p>  }</p>
<p>二：调用 oracle里面的过程<br>public CallableStatement casta =null;<br>protected ResultSet rs=null;<br>casta = con.prepareCall(“{call<br>pro_java(?,?)}”);<br>casta.setInt(1,20);<br>//给第一个参数传值<br>// 给第2个参数注入数据类型 游标<br>casta.registerOutParameter(2,<br>OracleTypes.CURSOR);<br>casta.execute();<br>// 2 代表 输出数据的位置<br>rs =(ResultSet)casta.getObject(2);<br>// 循环遍历结果<br>while(rs.next()){<br>rs.getInt(1);<br>rs.getString(2) ;<br>rs.getString(3);<br>}<br></p>
]]></content>
        <pubTime>2013-01-29T16:00:45.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/04/13/extjs4-little/</loc>
    <lastmod>2014-06-20T10:11:42.000Z</lastmod>
    <data>
        <display>
        <title>ext小知识点</title>
        <content><![CDATA[<p>Ext中的get、getDom、getCmp、getBody、getDoc的区别<br>get方法用来得到一个Ext元素,</p>
<p>getCmp方法－获得Ext组件,Ext.getCmp(“h2”).来得到id为h2的组件<br>getDom方法－获得DOM节点 Ext.getDom(“div2”),得到id为div2的html<br>DOM<br>getBody方法－得到文档的body节点元素 (Element)。<br>getDoc方法－获得与document对应的Ext元素(Element),<br>实质上就是把当前html文档对象，<br>也就是把document对象封装成ExtJS的Element对象返回，<br>该方法不带任何参数。</p>
<p>ExtJS 4.0新特性-动态加载和新的类系统:<br>JavaScript没有真正的面向对象的类系统，<br>因而对主流的熟悉面向对象语言的开发者来说存在着技术障碍。<br>ExtJS通过提供自己的类系统，从而让开发者可以编写一个更传统的<br>面向对象的代码。ExtJS 4.0对旧的类系统进行了<br>全面的更新提供了一个全新的类系统，从而让开发更简单、更灵活。<br>ExtJS 4.0推出4个新特性：类定义、mixins、输入和输出配置及依赖加载。</p>
<p>类定义。ExtJS 4.0引入了Ext.define方法，<br>可以通过类的字符串名定义和继承类，这就避免了由于类不存在报出的错误。<br>类管理器会自动检查类之间的依赖关系，因此，<br>我们不再需要维持一个严格的加载顺序。</p>
<p>mixins。许多动态语言都支持mixins的特性，<br>比如Ruby、Python。而JavaScript在语言层面没有mixins支持<br>，ExtJS 4.0自己实现了mixins的功能，mixins类似于多继承，<br>是一种细粒度的代码复用单元，它定义了一套可重用的行为和配置，<br>如果一个类需要某个特性，只需要将特性类混入目标类中。</p>
<p>输入和输出配置。即为配置项动态生成getter和setter方法，<br>并且这些方法也允许我们进行覆盖，这大大减少了代码量。</p>
<p>依赖加载。在4.0之前的版本中，都要在使用之前加载整个框架，<br>4.0中提供了Ext.require函数，通过它可以动态加载任何类，<br>并且它会加载依赖类，通过动态加载可以有效地减少客户端加载的库文件体积。</p>
]]></content>
        <pubTime>2014-04-13T14:19:07.000Z</pubTime>
        
         
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/tags/extJs/"/>
          
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/categories/extJs/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/01/19/extjs4-dataproxy/</loc>
    <lastmod>2014-06-20T10:11:38.000Z</lastmod>
    <data>
        <display>
        <title>extJs_数据代理</title>
        <content><![CDATA[<p>数据代理proxy是进行数据读写的主要途径,通过代理操作数据进行CRUD</p>
<p>每一步操作全会得到唯一的Ext.data.Operation实例他包含了所有的请求参数</p>
<p>1.数据代理proxy目录结构<br>Ext.data.proxy.Proxy<br>代理类的根类(他分为客户端(Client)代理和服务器代理(Server))<br>Ext.data.proxy.Client 客户端代理<br>Ext.data.proxy.Memory 普通的内存代理 ——[重点]<br>Ext.data.proxy.WebStorage 浏览器客户端存储代理<br>Ext.data.proxy.SessionStorage 浏览器级别代理（关了浏览器数据不在）——[重点]<br>Ext.data.proxy.LocalStorage<br>本地化的级别代理(不能夸浏览器,关了浏览器数据还在)——[重点]<br>Ext.data.proxy.Server 服务器端代理<br>Ext.data.proxy.Ajax 异步加载的方式——[重点]<br>Ext.data.proxy.Rest 一种特使的Ajax—[知道]<br>Ext.data.proxy.JsonP 跨域交互的代理——[重点] 跨域是有严重的安全隐患的<br>extjs的跨域也是需要服务器端坐相应的配合<br>Ext.data.proxy.Direct 命令.<br>3+方式的代理</p>
<p>资料<br>REST指Representational State Transfer (有时写作”ReST”)，表<br>示性状态转移，其要求无状态、客户端-服务器、具有缓存机制的通信协议——实际上是使用HTTP协议。<br>RESTful应用使用HTTP请求来POST数据（创建和/或更新）、读取数据（例如，进行查询）、删除数据。<br>这样，REST使用HTTP来进行CRUD（Create/Read/Update/Delete）操作。</p>
<p>代码：<br><code><br>//普通内存代理<br>(function(){<br>Ext.onReady(function(){<br>Ext.regModel(“user”,{<br>fields:[<br>{name:’name’,type:’string’},<br>{anem:’age’,type:’int’}<br>]<br>});<br>//不用create方法 我们直接用proxy来创建对象数据<br>var userData = [<br>{name:’uspcat.com’,age:1},<br>{name:’yunfengcheng’,age:26}<br>];<br>//创建model的代理类<br>var memoryProxy = Ext.create(“Ext.data.proxy.Memory”,{<br>data:userData,<br>model:’user’<br>})<br>userData.push({name:’new uspcat.com’,age:1});<br>//update<br>memoryProxy.update(new Ext.data.Operation({<br>action:’update’,<br>data:userData<br>}),function(result){},this);<br>//就可以做CRUD了<br>memoryProxy.read(new<br>Ext.data.Operation(),function(result){<br>var datas = result.resultSet.records;<br>Ext.Array.each(datas,function(model){<br>alert(model.get(‘name’));<br>})<br>});<br>});<br>})();</code></p>
<p>//localstorage本地化的级别代理(不能夸浏览器)</p>
<p>(function(){<br>Ext.onReady(function(){<br>Ext.regModel(“user”,{<br>fields:[<br>{name:’name’,type:’string’}<br>],<br>proxy:{<br>type:’localstorage’,<br>id : ‘twitter-Searches’<br>}<br>});<br>//我们用store来初始化数据<br>var store = new Ext.data.Store({<br>model:user<br>});<br>store.add({name:’uspcat.com’});<br>store.sync();<br>store.load();<br>var msg = [];<br>store.each(function(rec){<br>msg.push(rec.get(‘name’));<br>});<br>alert(msg.join(“n”));<br>})<br>})();</p>
<p>//异步ajax代理加载的方式</p>
<p>(function(){<br>Ext.onReady(function(){<br>Ext.regModel(“person”,{<br>fields:[<br>{name:’name’,type:’string’}<br>]<br>});<br>var ajaxProxy = new Ext.data.proxy.Ajax({<br>url:’person.jsp’,<br>model:’person’,<br>reader:’json’,<br>limitParam : ‘indexLimit’<br>});<br>ajaxProxy.doRequest(new Ext.data.Operation({<br>action:’read’,<br>limit:10,<br>start :1,<br>sorters:[<br>new Ext.util.Sorter({<br>property:’name’,<br>direction:’ASC’<br>})<br>]<br>}),function(o){<br>var text = o.response.responseText;<br>//传过来的是字符串，需解码<br>alert(Ext.JSON.decode(text)[‘name’]);<br>});<br>});<br>})();<br></p>
]]></content>
        <pubTime>2014-01-19T14:25:52.000Z</pubTime>
        
         
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/tags/extJs/"/>
          
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/categories/extJs/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/01/19/extjs3-data-model/</loc>
    <lastmod>2014-06-20T10:11:35.000Z</lastmod>
    <data>
        <display>
        <title>extJs_数据模型</title>
        <content><![CDATA[<p>数据模型基本要讲三个大部分 model proxy store</p>
<p>1.普通Molde的创建<br>数据模型对真实世界中对事物在系统中的反应 &nbsp; extjs4.0中的mode相当于<br>DB中的table 或 JAVA 中的Class<br>2.利用Ext.regModel创建模型<br>3.创建model的实例<br>3中实例化对象的方法<br>4.Validations<br>5.自定一验证器<br>Ext.data.validations.lengthMessage=”错误的长度”;<br>//扩展也就是我们自定义验证机制的的一个新的验证方法<br><code><br>Ext.apply(Ext.data.validations,{<br>age:function(config,value){<br>var min = config.min;<br>var max = config.max;<br>if(min&lt;=value  value&lt;=max){<br>return true;<br>}else{<br>this.ageMessage =<br>this.ageMessage+”它应该在”+mix+”到”+max+”范围内”;<br>return false;<br>}<br>},<br>ageMessage:’age数据出现了错误’<br>});<br>Ext.regModel(“person”,{<br>fields:[<br>{name:’name’,type=’auto’},<br>{name:’age’,type=’int’},<br>{name:’email’,type=’auto’}<br>],<br>validations:[<br>{type:’length’,field:’name’,min:2,max:6}<br>{type:’age’,field:’age’,min:0,max:150}<br>]<br>});<br>var p = Ext.create(“person”,{<br>name:”sjx”,<br>age:16,<br>email:”1038342063@qq.com”<br>});<br>var errors = p.validate();<br>var errorInfo = [];<br>errors.each(function(v){<br>&nbsp; errorInfo.push(v.field+”<br>“+v.message);<br>});<br>alert(errorInfo.join(“n”));</code></p>
<p>6.简单数据代理,详细的代理proxy要再后面课程讲<br>proxy 他就是来完成我们数据的CRUD,操作数据。<br>会发送一个请求过去，然后查出来的数据呢就放在model里面。<br>(function(){<br>Ext.onReady(function(){<br>Ext.regModel(“person”,{<br>fields:[<br>{name:’name’,type:’auto’},<br>{name:’age’,type:’int’},<br>{name:’email’,type:’auto’}<br>],<br>//代理—去请求数据，返回数据填充在model里<br>proxy:{<br>type:’ajax’,<br>url:’person.jsp’<br>}<br>});<br>//未填充数据的Model<br>var p = Ext.ModelManager.getModel(“person”);<br>//去加载，填充数据<br>p.load(2, {<br>&nbsp; &nbsp; &nbsp;<br>&nbsp;scope: this,<br>&nbsp; &nbsp; &nbsp;<br>&nbsp;failure: function(record, operation) {<br>&nbsp; &nbsp; &nbsp;<br>&nbsp;},<br>&nbsp; &nbsp; &nbsp;<br>&nbsp;success: function(record, operation) {<br>//成功之后返回的数据<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; alert(record.data.name);<br>&nbsp; &nbsp; &nbsp;<br>&nbsp;},<br>&nbsp; &nbsp; &nbsp;<br>&nbsp;callback: function(record, operation) {<br>&nbsp; &nbsp; &nbsp;<br>&nbsp;}<br>&nbsp; &nbsp; });<br>})<br>})();<br>7.Molde的一对多和多对一<br>&nbsp;在这我们先简单了解,在讲完Ajax之后我们在深入学习<br>teacher 1=&gt;n student</p>
<p>Ext.onReady(function(){<br>//类老师<br>Ext.regModel(“teacher”,{<br>fideld:[<br>{name:’teacherId’,type:”int”},<br>{name:’name’,type:”auto”}<br>],<br>hasMany:{<br>model: ‘student’,<br>&nbsp; &nbsp; name :<br>‘getStudent’,<br>&nbsp; &nbsp; &nbsp;<br>&nbsp; filterProperty: ‘teacher_Id’<br>}<br>});<br>//学生<br>Ext.regModel(“student”,{<br>fideld:[<br>{name:’studentId’,type:”int”},<br>{name:’name’,type:”auto”},<br>{name:”teacher_Id”,type:’int’}<br>]<br>});<br>//t.students 得到子类的一个store数据集合<br>});</p>
]]></content>
        <pubTime>2014-01-19T07:46:17.000Z</pubTime>
        
         
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/tags/extJs/"/>
          
              <breadCrumb title="extJs" url="http://www.shenjixiang.cn/categories/extJs/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/10/30/java-throuth/</loc>
    <lastmod>2014-06-20T10:11:17.000Z</lastmod>
    <data>
        <display>
        <title>java常用类</title>
        <content><![CDATA[<p>1.系统相关类<br>system类：</p>
<p>它是一个final类，所有方法和属性都是静态的。</p>
<p>属性有:inouterr分别是标准输入、输出、错误输出流。<br>方法：currentTimeMillis() 返回以毫秒为单位的当前时间<br>exit() 终止当前正在运行的JAVA虚拟机<br>gc() 运行垃圾回收器<br>nanoTime() 返回最准确的可用系统计时器的当前值，以毫秒为单位<br>getProperties() 确定当前系统属性<br>getPropertie(String key) 获得指定键指示的系统属性 属性表见书272页</p>
<p> runtime类: Runtime rt = new<br>Runtime.getRuntime();//它没有构造器<br>rt.freeMemory();//空闲内存数</p>
<p><font face="宋体">2.字符串相关类</font></p>
<p><font face="宋体">String类：一旦被创建，就是一个不可变的字符串。</font></p>
<p><font face="宋体">取长度用length();数组用length;<br>String str1 = new<br>String(“Hello”);<br>String str2 =<br>“Hello”;<br>String str3 =<br>“Hello”;<br>注意:str2与str3内存地址一样，而str1是实例了一个新的对象。<br>String常用方法：indexOf();返回指定字符出现的出现位置,<br>有很多的重载，根据需要输入。<br>截取：substring(0,4)<br>从下标为0的开始，到4-1结束，它返回的是字符串。<br>替换：replace(‘s’,’S’);把所有为s的替换为S.<br>toLowerCase();全部转为小写，toUpperCase():全部转为大写。</font></p>
<p>StringBuffer类：用它声明对象是一个内容可变的字符串。具体方法查api<br>StringBuilder类:很多方面与StringBuffer相同，不同的是StringBuffer方法是线程安全的，而StringBuilder不是。</p>
<p>date类：主要用于获取当前时间<br>方法：getTime()<br>返回1970年1月1日凌晨到目前的毫秒差</p>
<p>SimpleDateFormat类：主要用于获取格式化输出日期<br>列：Date n =<br>newDate();<br>SimpleDateFormat as =<br>newSimpleDateFormat(“yyyy年MM月dd日HH点mm分ss秒”）;<br>System.out.println(as.format(n));</p>
<p>GregorianCalendar类：主要用于日期时间操作<br>用法：<br>“&gt;GregorianCalendar cal =<br>new”&gt;GregorianCalendar();</p>
<p>System.out.println(“今天是今年的第”+cl.get(Calendar.DAY_OF_YEAR)+”天”);</p>
<p>System.out.println(“”&gt;今天是这个月的第”+cl.get(Calendar.DAY_OF_WEEK_IN_MONTH)+”周”);</p>
<p>System.out.println(“”&gt;今天”&gt;是今年的第”+cl.get(Calendar.WEEK_OF_YEAR)+”周”);</p>
]]></content>
        <pubTime>2012-10-30T15:52:03.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/11/05/java-reflect/</loc>
    <lastmod>2014-06-20T10:11:15.000Z</lastmod>
    <data>
        <display>
        <title>java反射</title>
        <content><![CDATA[<p>在java中，创建对象的四种方式：new 、 反射、 对象克隆、 对象反序列化。<br>类加载的过程：加载、连接（验证，准备，解析）、初始化三个阶段。<br>1.所谓反射，就是指在java中，可以在运行期载入、探知和使用编译期完全未知的类，通过使用java的反射机制，来获得类的成员变量、方法、构造器等。其实就是获得类的模版（是未被初始化的），然后来调用它里面的属性、行为等。<br>2.反射实现有三种：</p>
<p>第一种方式：在编译期不知道类名，但是在运行期可以获得该类名的时候，使用Class类的forName()静态方法可以获得Class对象。<br>例如：<br><code><br>Scanner sc=new Scanner(System.in);</code></p>
<p>System.out.println(“请输入”);</p>
<p>String s =sc.next();</p>
<p>Class<br>c=Class.forName(s);//全限定类名是字符串形式的。//包名.类名</p>
<p>Field[]<br>allFields = c.getDeclaredFields();//得到所有声明了的属性</p>
<p>Field[]<br>allPublicFields =c.getFields();//得到所有的公共属性</p>
<p>Constructor[] allPublicCons =<br>c.getConstructors();//所有公共的构造器</p>
<p>Constructor[] allCons =<br>c.getDeclaredConstructors();//所有的构造器</p>
<p>Object obj = ct.newInstance() //<br>调用构造器</p>
<p>for(int<br>i=0;i&lt;<span style="line-height: 28px;">allPublicCons.length;i++){<br>//<span style="line-height: 21px;">获取构造器的参数类型</span></span></p>
<p>if(cons[i].getGenericParameterTypes<wbr>().length&gt;0){</p>
<p>System.out.println(cons[i].getGenericParameterTypes<wbr>()[0]);</p>
<p>}<br> }</p>
<p>Method m[] =<br>c.getDeclaredMethods();<span style="line-height: 28px;">//所有的方法</span></p>
<p>for(int<br>i=0;i&lt;m.length;i++){</p>
<p>System.out.println(m[i].toString());</p>
<p>}<br></p>
<p>第二种方式：</p>
<p>如果在编译期知道类名的情况，可以调用该类的Class属性来获得该类对象的Class对象。例如：</p>
<p> Class c = 类名.class；<br>第三种方式：</p>
<p>如果有一个类的实例对象已经得到，则调用该对象的getClass()方法返回该对象所属类对应的Class对象。getClass()方法是java.lang.Object类的方法之一，所以所有对象都可以调用该方法。</p>
<p>Class c=对象名.getClass()；</p>
<p>垃圾回收：System.gc()或者Runtime.gc()方法是程序员与JVM的垃圾回收器进行通讯的唯一机制<br>当是执行gc()方法，并不能保证会立即回收垃圾，只能是促使回收器尽快回收。</p>
]]></content>
        <pubTime>2012-11-05T13:24:18.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/11/07/java-jcf/</loc>
    <lastmod>2014-06-20T10:11:14.000Z</lastmod>
    <data>
        <display>
        <title>java集合框架</title>
        <content><![CDATA[<p>特点：存入元素类型不同，集合长度可不，空间不固定。<br>java SE包含了由一组类和接口组成的java集合框架。<br>listsetmap<br>collections(工具类)<br>coolection(集合接口)<br>将对象储存有三种类型的接口：</p>
<p>1、Set(集)：对象容器中的对象没有顺序，且不能重复。：treeSet(排序，速度慢)，hashSet(不排序，速度快)</p>
<p>2、List(列表)：对象容器中的对象按照索引顺序排序，而且可以重复的对象。：ArrarList,vector,LinkedList(频繁增加、删除元素时使用);</p>
<p>3、Map(映射)：对象容器中的元素包含一对“键对象-值对象”映射，其中键对象不能重复，值对象可以重复。<span style="line-height: 28px;">：treeSet(排序，速度慢)，hashSet(不排序，速度快).</span></p>
<p>4.//泛型<br><code><br>List&lt;NewStudent&gt; list = new<br>ArrayList&lt;NewStudent&gt;();<br>list.add(new NewStudent(2));<br>list.add(new NewStudent(4));<br>list.add(new NewStudent(6));</code></p>
<p>列：Map map = new HashMap();<br>map.put(1, 1);<br>Set ks =<br>map.keySet();<br>Iterator ite =<br>ks.iterator(); //Iterator迭代器<br>while(ite.hasNext()){<br>Object obj = ite.next();<br>System.out.println(obj+”—-“+map.get(obj));<br>}<br>}<br><br>遍历：就是查看每一个元素</p>
]]></content>
        <pubTime>2012-11-07T14:01:44.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/11/10/java-io/</loc>
    <lastmod>2014-06-20T10:11:13.000Z</lastmod>
    <data>
        <display>
        <title>java I/O系统</title>
        <content><![CDATA[<p>本章讲的主要是对文件的操作：写入，读取。在指定目录下通过代码创建文件，文件夹等操作。<br>字节流：InputStream（将文件读入程序），OutputStream（将内容写到文件里）<br><span style="line-height: 21px; color: rgb(70, 70, 70); font-family: simsun;">字符流：Reader,writer都是抽象类，所以不能直接new<br>。文件 ====== 程序</span></p>
<p>1.实际上字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件。<br>[<img src="" alt="第十七章&lt;wbr&gt;java&lt;wbr&gt;I/O系统">javaI/O系统”  TITLE=”第十七章javaI/O系统” /&gt;]<br><code><br>public static void main(String[]<br>args){<br>try{<br>// 第1步：创建文件夹<br>  File f<br>= new File(“d:/gt09”); // 声明File 对象</code></p>
<p>f.mkdir();//创建文件夹</p>
<p>// 第2步：<span style="line-height: 28px;">创建文件<br><span style="line-height: 28px;">File f1 =<br>new File(“d:/gt09/SJX.txt”);<br><span style="line-height: 28px;"></span></span></span></p>
<p>f1.createNewFile();//创建一个文件<br>// 第3步：对文件进行写操作 </p>
<p>Properties prop = new<br>Properties();//与集合类map差不多，（键—值）类型的<br>String name = JOptionPane.showInputDialog(“请输入姓名”);<br>String sex = JOptionPane.showInputDialog(“请输入性别”);<br>String age = JOptionPane.showInputDialog(“请输入年龄”);<br>prop.put(“name”, name);<br>prop.put(“sex”, sex);<br>prop.put(“age”, age);</p>
<p>  OutputStream out = new<br>FileOutputStream(“<span style="line-height: 28px;">d:/gt09/SJX.txt”);<br>//保存当前的信息</span></p>
<p> prop.store(out, “人员信息”);</p>
<p>out.close();//关闭输出流<br>// <span style="line-height: 28px;">第4步：对文件进行读操作</span></p>
<p>InputStream in = new FileInputStream( <span style="line-height: 28px;">“<span style="line-height: 28px;">d:/gt09/SJX.txt<span style="line-height: 28px;">“);<br>//加载文件信息<br>prop.load(in);<br>//获取对应信息内容键的集合并且显示每个键对应的信息内容<br>Set keySet = prop.keySet();<br>Iterator ite = keySet.iterator();//运用迭代器进行操作<br>while(ite.hasNext()){<br>Object key = ite.next();<br>System.out.println(key + “:” +prop.get(key));<br>}<br> }<br> }<br></span></span></span></p>
]]></content>
        <pubTime>2012-11-10T13:57:09.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/01/17/thread-make-custom/</loc>
    <lastmod>2014-06-20T10:09:22.000Z</lastmod>
    <data>
        <display>
        <title>线程（生产者-消费者问题）</title>
        <content><![CDATA[<p><code><br>package com.my.test;</code></p>
<p>public class ProducerConsumer {<br>public static void main(String[] args) {<br>HC hc = new HC();<br>new Thread(new Producer(hc)).start();<br>new Thread(new Consumer(hc)).start();<br>}<br>}</p>
<p>class ManTou {<br>public String name = “”;</p>
<p>public ManTou(String name) {<br>this.name = name;<br>}<br>}</p>
<p>class HC {<br>private static int index = 0;<br>private static int num = 0;<br>ManTou[] mt = new ManTou[20];</p>
<p>public synchronized void put(int i) {<br>while (index == mt.length - 1) {<br>try {<br>this.wait();// 让出当前对象锁，等待别人唤醒<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}</p>
<p>ManTou m = new ManTou(“” + i);<br>mt[index] = m;<br>System.out.println(“生产：” + mt[index].name);<br>index++;<br>num = num + 1;<br>this.notify();<br>}</p>
<p>public synchronized void get() {<br>while (index &lt;= 0) {<br>try {<br>this.wait();<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}<br>if (num == 5) {<br>index—;<br>System.out.println(“消费：” + mt[index].name);<br>num = 0;<br>}<br>this.notify();<br>}<br>}</p>
<p>class Producer implements Runnable {<br>private HC hc;</p>
<p>public Producer(HC hc) {<br>this.hc = hc;<br>}</p>
<p>@Override<br>public void run() {<br>for (int i = 1; i &lt;= 20; i++) {<br>hc.put(i);<br>try {<br>Thread.sleep(10);<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>}<br>}</p>
<p>}</p>
<p>class Consumer implements Runnable {<br>private HC hc;</p>
<p>public Consumer(HC hc) {<br>this.hc = hc;<br>}</p>
<p>@Override<br>public void run() {<br>for (int i = 1; i &lt;= 20; i++) {<br>hc.get();<br>try {<br>Thread.sleep(10);<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>}<br>}<br>}<br></p>
]]></content>
        <pubTime>2014-01-17T09:23:21.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/01/17/thread-all/</loc>
    <lastmod>2014-06-20T10:09:21.000Z</lastmod>
    <data>
        <display>
        <title>线程总结</title>
        <content><![CDATA[<p>线程：<br>1、后台线程：设置Thread.setDaemon(true)就是后台线程了。<br>前台线程：不设置。<br>如果没有前台线程了，那么整个程序都会结束。</p>
<p>2、线程的合并：Thread.join(10000);<br>将子线程加入主线程，两个线程合并10秒后分开。</p>
<p>3、线程同步：a、synchronized(Object){ 代码块 }<br>Object必须是同一个对象才能进行同步。<br>b、在方法前面加synchronized。</p>
<p>new Thread(Object).start();<br>start只是准备运行，处于准备状态，并不是确定开始执行。</p>
<p>4、实现代码块与方法的同步：synchronized(Object)，<br>Object为Object.class（两个为同一个对象监视器）</p>
<p>死锁：你等我，我等你</p>
<p>5、线程间的通信：(要是同一个对象的waitnotifynotifyAll)</p>
<p>wait:告诉当前线程放弃监视器并进入睡眠状态，<br>直到其他线程进入同一监视器并调用notify为止。</p>
<p>notify:唤醒同一对象监视器中调用wait的第一个线程。<br>用于类似饭馆有一个空位后通知所有等候就餐的顾客中<br>的第一位可以入座的情况。</p>
<p>notifyAll:唤醒同一对象监视器中调用wait的所有线程，<br>具有最高优先级的线程首先被唤醒并执行。</p>
<p>6、生命周期：start—&gt;runnable—&gt;running—&gt;run()方法完成</p>
<p>7、方法：<br>suspend（阻塞）,resumen（恢复线程执行），stop（）<br>以上方法容易造成死锁。最好用一个变量去控制它的生命周期。</p>
<p>8、sleep方法：让当前线程休眠。自己拥有锁，不让出。<br>自己过一段时间可以醒。<br>而wait方法，是在等待，让出了锁，需要别人叫醒。<br>yield方法：让出cpu，给其他线程执行机会。</p>
<p>9、线程的优先级（Priority）：默认为5。</p>
]]></content>
        <pubTime>2014-01-17T09:48:09.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/01/16/reflect/</loc>
    <lastmod>2014-06-20T10:08:29.000Z</lastmod>
    <data>
        <display>
        <title>反射</title>
        <content><![CDATA[<p><code><br>try {</code></p>
<p>//1.根据类的完整路径获取<br>   Class claz1 = Class.forName(“org.bruce.base.BaseDaoImpl”);</p>
<p>//2.把类引入当前java类,通过 “类.class”获取<br>   Class claz2 = BaseDaoImpl.class;</p>
<p>//3.new一个对象,通过对象的实例获取<br>BaseDaoImpl bi = new BaseDaoImpl();<br>   Class claz3 = bi.getClass();</p>
<p>//创建实例<br>   Object obj = claz1.newInstance();</p>
<p>//Class所涉及到的东西:</p>
<p>  //1.类的名称</p>
<p>claz1.getName();</p>
<p>claz1.getSimpleName();</p>
<p>  //2.类的构造函数</p>
<p>claz1.getConstructors();</p>
<p>claz1.getConstructor(String.class,Integer.class);//根据构造函数参数类型和个数获取构造函数</p>
<p>  //3.类的修饰符<br>claz1.getModifiers();</p>
<p>  //4.类的属性</p>
<p>claz1.getFields();</p>
<p>claz1.getDeclaredFields();</p>
<p>claz1.getDeclaredField(“属性名,比如:username”);</p>
<p>  //5.类的方法</p>
<p>claz1.getMethods();</p>
<p>claz1.getDeclaredFields();</p>
<p>claz1.getDeclaredMethod(“set”, String.class);</p>
<p>//Field涉及的东西:</p>
<p>   Field f =claz1.getDeclaredField(“uname”);</p>
<p>//1.属性名称<br>f.getName();<br>//2.属性的值类型(String,int,long等)<br> f.getType();</p>
<p>//Method涉及的东西:<br>   Method m =claz1.getDeclaredMethod(“getName”);</p>
<p>//1.方法名称<br>  m.getName();<br>//2.执行方法(invoke)</p>
<p>m.invoke(obj, args);</p>
<p> } catch (Exception e) {</p>
<p>e.printStackTrace();</p>
<p> }<br> </p>
]]></content>
        <pubTime>2014-01-16T12:23:55.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/10/18/java-dt/</loc>
    <lastmod>2014-06-20T10:08:12.000Z</lastmod>
    <data>
        <display>
        <title>java的多态</title>
        <content><![CDATA[<p>1.多态：按照字面意思理解就是多种状态，比如水有固液气三态。<br>静态多态：实现方式即方法重载。</p>
<p>动态多态：实现方式为重写父类中的同名成员方法。<br>列子：<br><code><br>public class<br>Student{//父类<br>public void fangfa(){<br>}<br>}<br>public class LovoStudent extends<br>Student{//子类<br>//在子类中声明定义fangfa()，写输出<br>public void fangfa(){<br> System.out.println(“吃饭了”);<br>}<br>Student<br>stu=newLovoStudent();<br>当stu调用时，只能调用父类的方法，属性，如果子类有重写方法会调用子类的方法而不条用父类的方法。<br>注意：子类的引用不能指向父类 比如LovoStudent lovo=<br>newStudent();<br>instanceof关键字能够判断对象的真正类型<br>Student<br>stu=newStudent();<br>LovoStudent lovo<br>=newLovoStudent();<br>if(lovoinstanceofStudent){</code></p>
<p>System.out.println(“是的”);<br>}else{</p>
<p>System.out.println(“不是的”);<br>}<br><br>列如猫（父类）的子类波斯猫，只能说波斯猫是猫，而不能说猫一定是波斯猫。</p>
]]></content>
        <pubTime>2012-10-18T12:36:00.000Z</pubTime>
        
         
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/tags/%E5%9F%BA%E7%A1%80/"/>
          
              <breadCrumb title="基础" url="http://www.shenjixiang.cn/categories/%E5%9F%BA%E7%A1%80/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/04/07/mongodb1/</loc>
    <lastmod>2014-06-20T10:06:45.000Z</lastmod>
    <data>
        <display>
        <title>mongoDB_1</title>
        <content><![CDATA[<p>安装：<br>1.解压到D:mongo，新建D:mongoDB目录<br>2.cmd到D:mongobin目录，输入：mongod —logpath<br>D:mongologsmongodb.log —logappend —dbpath D:mongoDB<br>—directoryperdb —serviceName MongoDB —install<br>该命令行指定了日志文件：/logs/MongoDB.log，日志是以追加的方式输出的；<br>数据文件目录：/data/db，并且参数—directoryperdb说明每个DB都会新建一个目录；<br>Windows服务的名称：MongoDB；<br>以上的三个参数都是可以根据自己的情况而定的。<br>最后是安装参数：—install，与之相对的是—remove<br>以后就可以在cmd下用命令net start MongoDB和net stop<br>MongoDB来启动和停止MongoDB了，也可以在本地服务中看到</p>
<p>MongoDB与MySQL对应<br>database   database<br>table collection<br>index index<br>row BSON?document<br>column BSON field<br>join embedding and linking<br>primary key _id field<br>group by aggregation</p>
<p>它的shell是一个javascript引擎，因此可以使用javascript语言。<br>但是特殊的操作，要靠驱动包来完成（java，nodejs）。<br>db.person.insert({_id:1,name”123”,age:25})</p>
<p>db.person.remove({_id:1})</p>
<p>db.person.update({_id:1},{name:”23”})</p>
<p>单表查询非常强大，但是级联的话就没支持了。</p>
<p>db.person.find({country:{$in:[“USA”,”China”]}},{_id:0,name:1})</p>
<p>索引：<br>二维索引：</p>
<p>固定集合：常用于日志<br>锁：上锁，用于数据库备份，备份好后解锁。<br>数据修复：db.repairDatabase()<br>主从试集群:<br>副本集：<br>分片：集群：路由—》配置服务器—》片区1</p>
<p>—》片区2</p>
<p>3.什么时候用到分片呢?</p>
<p> 3.1机器的磁盘空间不足</p>
<p> 3.2单个的mongoDB服务器已经不能满足大量的插入操作</p>
<p> 3.3想通过把大数据放到内存中来提高性能</p>
<p>4.分片步骤</p>
<p> 4.1 创建一个配置服务器</p>
<p> 4.2 创建路由服务器,并且连接配置服务器</p>
<p>  路由器是调用mongos命令</p>
<p> 4.3 添加2个分片数据库</p>
<p> 10000和20000</p>
<p> 4.5 利用路由为集群添加分片(允许本地访问)<br>切记之前不能使用任何数据库语句</p>
<p>db.runCommand({addshard:”127.0.0.1:10000”,allowLocal:true})</p>
<p>db.runCommand({addshard:”127.0.0.1:20000”,allowLocal:true})<br>4.6 打开数据分片功能,为数据库foobar打开分片功能</p>
<p>db.runCommand({“enablesharding”:”foobar”})<br>4.7对集合进行分片</p>
<p>db.runCommand({“shardcollection”:”foobar.bar”,”key”:{“_id”:1}})<br>4.8利用大数据量进行测试 (800000条)<br>4.9在每个片区查询数据<br>5.查看配置库对于分片服务器的配置存储</p>
<p> db.printShardingStatus()<br>6.查看集群对bar的自动分片机制配置信息<br>mongos&gt; db.shards.find()</p>
]]></content>
        <pubTime>2014-04-07T04:23:15.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/09/09/mysql-lsb/</loc>
    <lastmod>2014-06-20T09:58:52.000Z</lastmod>
    <data>
        <display>
        <title>mysql_临时表加个人理解</title>
        <content><![CDATA[<p>首先说明临时表只存在于内存中，他是一个select语句 用在from 后面！！<br>写个经典列题来分析一下就明白了（老师上课讲的）<br>查询每个班的最高分学生是那些?（可能有相同的成绩）<br>这里不能用select max(grade) from student group by<br>class:如果这样的话，只能显示每个班的最高的那一个而已，并不能显示所有的最高分，这也是我问过老师的。<br>select * from<br>(select name,class,chengji, from student,chengji, where<br>student.fk = chengji.id) as a,<br>(select class,max(chengji) as xx from student,chengji where<br>student.fk = chengji.id group by class)as b<br>where a.class = b.class and a.chengji=b.xx;<br>分析：首先创建了两张临时表，一张是所有学生的信息，另一张当然是每个班的最高成绩信息，</p>
<p>只要通过班级名称就能将两张表连接起来，必能够显示每个班的最高分有哪些，用班级来做链接是最完美不过的了，也只有这种方法来连接，上课已经讨论过了，这还是需要动些脑子的<br>那前几天不能做完美的题也就一并解决了！</p>
]]></content>
        <pubTime>2012-09-09T09:31:54.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/09/11/ssh-zj/</loc>
    <lastmod>2014-06-20T09:50:48.000Z</lastmod>
    <data>
        <display>
        <title>SSH(Spring Struts Hibernate)总结-----所有知识点</title>
        <content><![CDATA[<p>Hibernate:是一个持久层的框架，将关系型数据库与面向对象做一个转换，通过映射文件(自动处理对象直间的关系)。封装了增删改查方法，并且配置有缓存，hibernate用的好提高效率，用的不好程序会很慢。并且有hql语句(直接按照对象来操作数据库)。在依据hql获取用户信息时，继承了HibernateDaoSupport类的类中不能在使用Query类了，而是用List&lt;Ssh&gt;<br>list = this.getHibernateTemplate().find(hql);形式来获取实体类集合。</p>
<p>Struts:一个应用了前端控制器的mvc框架。在web.xml配置一个servlet用于将我们的请求拦截到一个中央控制器，然后由它传给每个不同的请求处理。如果有formBean,先将数据封装到formBean里去，还可以进行数据验证。然后交给action处理。</p>
<p>Spring:一个应用了AOP(面向切面)与IOC(反转控制)的轻量级容器框架。AOP:应用动态代理，将主要核心业务与辅助业务分离开，使业务更加清晰。动态代理：在一个对象上加上附加的代码，构成一个新的对象，就是代理对象。Spring将各个通知植入到被调用方法的周围。通过通知者(advisor)去定义在哪个方法植入哪个通知。</p>
<p>管理hibernate里的daoBean/serviceBean/sessionFactory以及事物对象,struts里的action对象。<br>感觉用了ssh框架之后，写代码非常少。管理也变的很简单了。</p>
]]></content>
        <pubTime>2013-09-11T15:07:44.000Z</pubTime>
        
         
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/tags/j2EE/"/>
          
              <breadCrumb title="j2EE" url="http://www.shenjixiang.cn/categories/j2EE/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/28/sql-dt/</loc>
    <lastmod>2014-06-20T09:50:26.000Z</lastmod>
    <data>
        <display>
        <title>Oracle_动态sql</title>
        <content><![CDATA[<p>早期绑定（编译时完成绑定处理）、晚期绑定（执行时才绑定）。<br>动态sql（晚期绑定）</p>
<p>不能再begin里直接create，因为它既要创建它，又要获得它的权限，所以有冲突。就出现了动态sql来解决。<br>语法：execute immediate 跟要执行语句的字符串形式。动态sql一般用于ddl语句。<br>绑定变量：解决效率，绑定变量，避免重复执行，提高性能。不能绑定对象（表,视图，列）、只能对于对象。</p>
<p>execute immediate ‘ update emp set sal=sal*2<br>where empno= :x’ using &amp;p_empno;</p>
]]></content>
        <pubTime>2013-01-28T14:10:09.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/28/plsql-package/</loc>
    <lastmod>2014-06-20T09:44:42.000Z</lastmod>
    <data>
        <display>
        <title>Oracle_pl/sql子程序和包</title>
        <content><![CDATA[<p>— 查询用户自己创建的对象<br>select * from user_source;<br>—输入参数：in<br>—输出参数：out<br>—输入参数：in out<br>drop package pack_name;<br>— 包<br>— 包规范（相当于java中接口）一种规范<br>create or replace package pack_name is<br> procedure pro_name(v_id<br>number) ;<br> function fun_name(v_id<br>number default 5) return number;<br>end pack_name;<br>— 包体（实现类）<br>create or replace package body pack_name is<br> procedure pro_name(v_id<br>number)is<br>  v_ename<br>varchar2(50);<br> begin<br>  select<br>ename into v_ename from emp<br>  where<br>empno = v_id;</p>
<p>dbms_output.put_line(v_ename);<br> end;<br>—函数</p>
<p>function<br> fun_name(v_id number<br>default 5) return number is</p>
<p>begin<br>  return<br>v_id + 1;<br> end;<br>end pack_name;<br>call pack_name.pro_name(7369);<br>—测试<br>declare<br>v_num number(5);<br>begin<br>pack_name.pro_name(7369);<br>v_num:=pack_name.fun_name();<br>dbms_output.put_line(v_num);<br>end;<br>函数与过程区别：<br>函数：必须有return关键字，必须返回单个值，必须包含至少一条return，作为表达式的一部分调用。<br>过程：不含return,没有返回值，作为pl/sql语句执行。</p>
]]></content>
        <pubTime>2013-01-28T14:28:27.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/22/plsql-jg/</loc>
    <lastmod>2014-06-20T09:44:22.000Z</lastmod>
    <data>
        <display>
        <title>Oracle_pl/sql程序控制结构</title>
        <content><![CDATA[<p>1.if语句<br>if mod(a,2)=0 then<br>dbms_output.pu_line(‘2’);<br>elsif mod(a,3)=0 then</p>
<p>dbms_output.pu_line(‘3’);<br>else<br>dbms_output.pu_line(‘null’);<br>end if;<br>2,case<br>case<br>when B&gt;100 and B&lt;200<br>then<br>dbms_output.pu_line(‘123’);<br>when B&gt;200 then<br>dbms_output.pu_line(‘456’);<br>else(默认值)</p>
<p>dbms_output.pu_line(‘…’);</p>
<h1 id="end_case;">end case;</h1>
<p>3.loop<br>loop<br>v_id:=v_id+1;<br>  if mod(v_id,2)=0<br>then<br>dbms_output.pu_line(‘…’);<br>  end if;<br>exit when v_id=100;<br>end loop;<br>4.for<br>for i in 1..100 loop<br>if mod(i,5)=0 then<br> dbms_output.pu_line(‘…’);<br>end if;<br>end loop;<br>5.while<br>while v_id&lt;100 loop<br> dbms_output.pu_line(v_id:=v_id+2);</p>
<h1 id="end_loop;">end loop;</h1>
<p>异常<br>1.系统自动抛出异常<br>declare<br>   v_id<br>number(5);<br>begin<br>   v_id<br>:= 5/0;</p>
<p>dbms_output.put_line(‘cs’);<br>exception<br>   when<br>others then</p>
<p>dbms_output.put_line(‘exception’);<br>end;<br>2.使用raise语句抛出异常<br>declare<br>e_no exception;<br>begin<br>update emp set deptno=&amp;no where<br>empno=&eno;<br>if sql%notfound then<br>raise e_no;<br>end if;<br>exception<br>when e_no then<br>dbms_output.put_line(‘该雇员不存在。。’);<br>end;<br>3.使用内置函数raise_application_error抛出异常窗口<br>if v_id =0 then</p>
<p>raise_application_error(-20000,’XX’);<br>end if;</p>
]]></content>
        <pubTime>2013-01-22T11:43:17.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/29/pl-sql/</loc>
    <lastmod>2014-06-20T09:44:00.000Z</lastmod>
    <data>
        <display>
        <title>Oracle_pl/sql触发器</title>
        <content><![CDATA[<p>了解：触发器是一种pl/sql命名块，在特定的事件发生时，会自动的配数据库执行。分为三种：dml触发器，系统事件触发器，instead<br>of触发器。而我们只学习了dml触发器（只能对单张表）。</p>
<p>create or replace<br>trigger tri_cfq<br>before | after<br>insert | delete<br>| update |<br>update of 列名<br>on 表名<br>for each row<br>写了表示每行触发一次(行级触发器)，不写就是语句级触发器。<br>begin<br>end;<br>:new 得到新添加的一行数据。<br>:old 得到以前数据库中一行的数据。<br>触发器还会用于主键自动增长。</p>
<p>create sequence seq_name_tri ;<br>create or replace trigger<br>tri_trinameinsert<br>before<br>insert on t_trigger<br>for each row  — 行级触发器<br>begin<br> select<br>seq_name_tri.nextval into<br>  :new.pk_id from<br>dual;<br>end;</p>
]]></content>
        <pubTime>2013-01-29T12:51:41.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/23/oracle-zj/</loc>
    <lastmod>2014-06-20T09:42:56.000Z</lastmod>
    <data>
        <display>
        <title>Oracle_总结</title>
        <content><![CDATA[<p>在pl/sql中更改数据和管理事务<br>1、dml操作的游标属性<br>游标一般指向最近的数据，其实游标相当于一个指针，指向私有工作区。<br>2.隐式游标的相关属性<br>属性名：sql%rowcount，sql%found<br>3.在oracle中添加数据时，必须使用values,不能使用value<br>4,使用forall语句的批量DML，目的为了提高代码执行的效率<br>5，forall处理批量DML语句：减少pl/sql与sql引擎的交互。<br>数据库事物管理<br>解释如下：<br>原子性 一致性 隔离性<br> 持久性<br>其中 一致性：commit rollback 用于解锁，结束事物<br>commit:从内存到磁盘<br>rollback :清内存</p>
]]></content>
        <pubTime>2013-01-23T14:12:52.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/28/oracle-cusor/</loc>
    <lastmod>2014-06-20T09:42:13.000Z</lastmod>
    <data>
        <display>
        <title>Oracle_游标获取数据</title>
        <content><![CDATA[<p>1.游标分为显示游标{静态、动态（系统sys_refcursor）}、隐示游标。静态游标比动态游标快.<br>游标每次只能指向一行数据,所以要用循环获取数据。<br>1.声明显示游标(静态)：<br>cursor cur_cursor is select语句<br>2.打开游标:<br>opencur_cursor<br>3.获取数据：<br>fetchcur_cursorinto 变量;<br>用loop循环时，退出条件是exit<br>whencur_cursor%notfound;<br>4.关闭游标：<br>closecur_cursor;<br>动态游标：<br>1.type<br>type_cursor is ref cursor;</p>
<p>var_cursor type_cursor;<br>动态游标不能声明v_infotype_cursor%rowtype;<br>2.open var_cursor for select</p>
<ul>
<li>from emp;<br>没什么，就是这些了、、</li>
</ul>
]]></content>
        <pubTime>2013-01-28T13:45:33.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/21/oracle-base/</loc>
    <lastmod>2014-06-20T09:41:44.000Z</lastmod>
    <data>
        <display>
        <title>Oracle_编程基础</title>
        <content><![CDATA[<p>1.匿名块（没名字，一般做测试）：</p>
<p>declare</p>
<p>begin</p>
<p>end;</p>
<p>2.命名块：子程序、触发器。</p>
<p>子程序：过程、包、函数.</p>
<p>过程：create or replace procedure pro_add(v_num number) is</p>
<p>—声明变量</p>
<p>begin</p>
<p>—执行语句</p>
<p>exception</p>
<p>—处理异常</p>
<p>end;</p>
<p>3.常用的标量数据类型：</p>
<p>varchar2(n),char(n),number(m,n),timestamp(oracle9i新增数据类型)，longlong<br>raw,boolean,binary_integer,binary_float,binary_double.</p>
<p>使用%type属性:v_name emp.ename%type;</p>
<p>v_vb emp%rowtype;</p>
<p>集合类型(类似数组)：</p>
<p>type type_deptName is table of varchar2(50) index<br>by binary_integer;</p>
]]></content>
        <pubTime>2013-01-21T13:44:16.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2013/01/16/oracle-1/</loc>
    <lastmod>2014-06-20T09:41:17.000Z</lastmod>
    <data>
        <display>
        <title>oracle第一章</title>
        <content><![CDATA[<p>第一章<br>实例：一个客户端连接oracle就是一个实例。</p>
<p>后台结构<br>实例：<br> SGA(内存共享区)<br>Oracle第一次执行SQL语句时，SQL语句解析结果放在SQL共享区的<br>内存结构：</p>
<p>PGA(非共享内存区)</p>
<p>物理结构<br>DB:<br>逻辑结构</p>
<p>Oracle在系统全局区SGA中开辟了多个缓冲 区域，以内存为代价，换取高性能，包括<br>数据库缓存、重做日志缓存、共享池、大池等。</p>
<p>Oracle对SQL处理过程包括四个步骤：语法检查、语义检查、SQL语句解析、执行SQL<br>并返回结果。</p>
<p>Oracle第一次执行SQL语句时，SQL语句解析结果放在SQL共享区的</p>
<p>数据库词典中保存的数据库对象包括：用户、角色、表空间、表、视图（view<br>隐藏原始信息、一种虚表）、簇、类型、同义词（相当于取别名）、序列、索引、数据库链接、存储过程、函数、包、触发器等。<br>序列（Sequence）：用于实现主键自动增长的。<br>语法：create sequence 序列名 increment by<br>增量种子数 start with 起始数字 maxvalue 最大值（可不写）。<br>分页操作：rownum（总是从1条数据开始的）<br>查询11条到20条数据：<br>select <em> from(select emp.</em>,rownum rn from emp)<br>a<br>where a.rn between 11 and 20;</p>
]]></content>
        <pubTime>2013-01-16T12:53:49.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/09/06/mysql8/</loc>
    <lastmod>2014-06-20T09:35:37.000Z</lastmod>
    <data>
        <display>
        <title>mysql_8</title>
        <content><![CDATA[<p>这章讲的是多表连接，当数据涉及到两张表时用于多表的连接<br>连接的几种方式：内连接，外连接（做外链接、右链接、全外连接），交叉连接。<br>1.使用两张表相等连接<br>内连接：<br>select table1.name,table2.name from table1,table2 where<br>talbe1.name=table2.name;<br>左外连接（显示左边的全部数据，包括空的值)：</p>
<p>select table1.name,table2.name from<br>table1 leftjoin table2 on<br>talbe1.name=table2.name;<br>右外连接（显示右边的全部数据，包括空的值)：<br>select table1.name,table2.name from<br>table1rightjointable2ontalbe1.name=table2.name;</p>
<p>2.非相等连接<br>select * from table1，table2 where<br>table1.column1&lt;table2.column2；<br>写个列子：</p>
<p>查询与张三有相同分数的学生信息</p>
<p>SELECT * FROM student JOIN chengji ON<br>student.fk=chengji.id<br>AND chengji=(SELECT chengji.chengji FROM chengji,student<br>WHERE student.fk=chengji.id AND<br>NAME=张三)<br>AND NAME!=张三;</p>
<p>小小用法终结：<br>1.连接：数据来源多表时用连接。<br>2.having 对统计数据的处理。<br>3.函数 放在select /having 后。<br>4.子查询 数据不能直接表达时用。</p>
]]></content>
        <pubTime>2012-09-06T01:15:03.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/08/31/mysql6/</loc>
    <lastmod>2014-06-20T09:29:55.000Z</lastmod>
    <data>
        <display>
        <title>mysql_6</title>
        <content><![CDATA[<p>昨晚本来想更新的，结果网路太卡，所以留在了今天。<br>先说说第五章剩余的， 排序操作 order by<br>表名A，表名B；这是根据两张表来排序，先排A，如果A有重复再排B。默认为从小到大，可用desc降序。排除重复用<br>distinct。分组用 group by<br>列1：select <em> from table_name where 条件（只能跟条件）group by 列名 order<br>by distinct 列名；<br>第六章：<br>1.函数 COUNT(列名)统计这列有多少行，<br>SUM(列名) 计算和，<br>ANG（列名）计算平均值，<br>MAX（列名）计算最大值，<br>MIN(列名）计算最小值；<br>注意：函数只能放在select后面！除count外，其余数据类型必须为整形或浮点型!!<br>列2.select name,count（</em>),sum(number) from<br>table_name where name like ‘%吉祥%’ group by name order by name desc<br>limit 5 having count(*)&gt;5;<br> 这是一个用了很多内容的查询，包含了很多得内容！！<br>3.SQL语句执行顺序<br>from 子句<br>where 子句<br>group by 子句<br>select 子句<br>having 子句<br>order by 子句</p>
]]></content>
        <pubTime>2012-08-31T02:38:22.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/09/05/mysql7/</loc>
    <lastmod>2014-06-20T09:29:13.000Z</lastmod>
    <data>
        <display>
        <title>mysql_7</title>
        <content><![CDATA[<p>有一段时间没更新了，呵呵，昨晚断网，前几天停电，这几天很是不爽艾普，网路不好使啊！！<br>第七章讲的是子查询，内容还是简单。<br>1.子查询作为计算列<br>select name,(子查询) as name1 from 表名；<br>2.where 中的子查询<br>select name from table where name2=(子查询）；如果子查询返回多个结果用IN！<br>3.子查询中使用运算符<br> EXISTS 他表示后面是否有返回值，如果有就执行前面的查询。<br>列：select studentid,name from student s<br>where exists(select studentid from studentexam<br>e<br>where mark &lt;40 and e.studentid =<br>s.student);<br>all 是一个一个比较数据 必须大于所有的值才能返回，而any只要大于其中一个就行了。<br>列：select columnA from tableA where columnA<br>&gt;all(select columnB from tableB);<br>4.组合查询<br>union、union all、intersect、difference<br>列：select columnA，columnB from tableA<br>union<br>select columnC，columnD from tableD;<br>两个select的后面 列数相等，数据类型可不一致，union 就是把两张分开的表联合起来摆了！！<br>以后记得每天一篇!!!</p>
]]></content>
        <pubTime>2012-09-05T01:01:24.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/08/29/mysql5/</loc>
    <lastmod>2014-06-20T09:28:44.000Z</lastmod>
    <data>
        <display>
        <title>mysql_5</title>
        <content><![CDATA[<p>今天学习了简单的数据查询语句，没讲完，因为老师说我们单词记不到！竟写错，所以就停留下来了，加油记单词！！<br>好吧！进入今天的正题。<br>首先是查询的基本结构:<br>先说select 的意思为投影 记得老师说的大意是提取数据吧。<br>1.select 列名1，列名2 from 表名 where 条件；<br>2.select <em> from 表名 where 条件；</em>代表所有的列。<br>下面讲的是跟在where后的：<br>1.模糊查询like 跟在where后与%或<em>联用。<br>2.%是通配符 代表一个或多个字符串，</em>是占位符 代表这个位必须有一个字符。<br>3.between  and<br>表示在两者之间包括边界值</p>
]]></content>
        <pubTime>2012-08-29T15:01:32.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/08/28/mysql4/</loc>
    <lastmod>2014-06-20T09:28:29.000Z</lastmod>
    <data>
        <display>
        <title>mysql_4</title>
        <content><![CDATA[<p>今天的学习让我对数据库有了更深一层的了解，让我在创建数据库<span style="line-height: 28px;">方面有很多细节的东西需要注意。<br>第四章 使用DML语句更改数据<br>1.添加新数据：<br>1.1 插入单行记录 insert into 表名 （列名，列名，<span style="line-height: 28px;">列名） values（值，<span style="line-height: 28px;">值，<span style="line-height: 28px;">值，）；<br>需注意列的值要与数据类型一一对应！！如果不写列名则表示要给每个列添加数据！<br>1.2 插入多行记录 insert into 表名<br>values（值，值，值，值），<br><span style="line-height: 28px;">（值，值，值，值），<br><span style="line-height: 28px;">（值，值，值，值），<br><span style="line-height: 28px;">（值，值，值，值）；<br>实例：insert into student（studentid，studentname）<br>values（1，‘john’）；<br>2.更改列数据<br>update 列名 set 修改后的列1，列2，….，… where 列条件；</span></span></span></span></span></span></span></p>
<p><font color="#000BFF">强调：如果不使用where字句 则更新全表数据！！<br>实例：update products set unitprice = unitprice*2 where productid=1；<br>3.删除数据<br>3.1 delete from 表名 where删除的条件；<br>实例：delete from table where id&gt;18；<br>3.2 使用truncate语句<br>truncate table 表名； 它的效率快 与delete的区别在于<br>他是直接对日志文件操作，不会留下详细的删除记录日志，数据将被永久删除，不会触发触发器。<br>今天的总结就这些了！背单词！！</font></p>
]]></content>
        <pubTime>2012-08-28T12:48:46.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/08/27/mysql3/</loc>
    <lastmod>2014-06-20T09:28:04.000Z</lastmod>
    <data>
        <display>
        <title>mysql_3</title>
        <content><![CDATA[<p>今天学习了许多的知识，很多啊，终结如下：</p>
<p>说先数据的完整性概述，分为四类：实体完整性、域完整性、引用完整性和用户自定义完整性。其实数据的完整性是对数据的限制。<br>设置主键约束 primary<br>key它强调数据不能为空，不能重复。后面可加auto_increment表示主键自动增长。<br>设置唯一约束 unique 他表示每一行是不同的。<br>设置默认值 default 给数据默认一个值，如果是字符串必须加‘’<br>设置检查约束 check（） 但它在mysql中无效。<br>下面是引用完整性首先两张表的格式要相同。<br>格式如下：<br>constraint 约束名 foreign key（这张表的列名）<br>references 另一张表名（列名）<br>声明表的格式是在创建表的末尾写上 engine = innodb<br>表的格式还有5种，另外两种是myisam 和 temp（临时表）<br>其实两张表是通过外间来连接的<br>引用的必须是约束的主键！！</p>
]]></content>
        <pubTime>2012-08-27T13:08:55.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2012/08/24/mysql2/</loc>
    <lastmod>2014-06-20T09:27:55.000Z</lastmod>
    <data>
        <display>
        <title>mysql_2</title>
        <content><![CDATA[<p>数据库的第二天，终结如下：<br>1.库的创建 create database 数据库名；<br>2.表的创建 create table 表名（列名1 列的数据类型，<br>   列名2<br>数据类型，<br>。。。<br>）<strong>charset = ‘utf8’；</strong><br>把表放在数据库中要用 <strong>use 数据库名；</strong><br>来完成<br><strong>3.</strong>删除数据库 drop database 数据库名；<br>4.删除表 drop table 表名；<br>5.修改表 a 在表中添加一个新列 alter table 表名 add 列名<br>数据类型；<br>b 修改表名 alter table 表名 rename to 新表名；<br>c 修改列 alter table 表名 change 列名 新列名<br>数据类型；<br>d 删除列 alter table 表名 drop<br>列名；<br>6.索引 查询优化 基本原理为二分法，当然还有其他算法的，并不是越多越好的，得看情况而定了，知道了吗 !<br>创建索引 create index 索引名 on 表名<br>（列名，列名，。。。。）；<br>删除索引 drop index 表名。索引名；<br>基本上就这些了，下面是数据类型：<br>1.浮点型：folate型和decimal型 decimal（总位数.小数点位数）；<br>使用时要特别小心decimal型！！不能超出范围咯。。<br>2.字符串型 char型是定长字符数据，默认为1，最长为16字节，超过会自动截取的，如果有空会用空格填充。这是他的特点。<br>varchar型是变长字符型数据就不一样了，他必须指定长度，其长度不会超过8kb，如果超过的话会占用其他空间，所以用的时候要小心咯，格式为<br>varchar（长度）<br>3.text型是保存日志的，作了解就行了。<br>4.日期和时间数据类型：<br>year型 格式：2012<br>date型 2012-12-28<br>datetime型 2012-12-28 00:00:00<br>第二章就基本ok了，讲一下今天上课感觉挺好的，老师很帅啊！</p>
]]></content>
        <pubTime>2012-08-24T13:41:20.000Z</pubTime>
        
         
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
              <breadCrumb title="数据库" url="http://www.shenjixiang.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
          
        </display>
    </data>
    </url>

    
  <url>
    <loc>http://www.shenjixiang.cn/2014/03/29/linux-sh/</loc>
    <lastmod>2014-06-19T15:47:46.000Z</lastmod>
    <data>
        <display>
        <title>linux的sh脚本编程</title>
        <content><![CDATA[<p>在Linux系统中，虽然有各种各样的图形化接口工具，但是sell仍然是一个非常灵活的工具。Shell不仅仅是命令的收集，而且是一门非常棒的编程语言。您可以通过使用shell使大量的任务自动化，shell特别擅长系统管理任务，尤其适合那些易用性、可维护性和便携性比效率更重要的任务。<br>下面，让我们一起来看看shell是如何工作的：<br>1.　建立一个脚本<br>Linux中有好多中不同的shell，但是通常我们使用bash<br>(bourne again shell)<br>进行shell编程，因为bash是免费的并且很容易使用。所以在本文中笔者所提供的脚本都是使用bash（但是在大多数情况下，这些脚本同样可以在bash的大姐，bourne<br>shell 中运行）。<br><a id="more"></a><br>如同其他语言一样，通过我们使用任意一种文字编辑器，比如nedit、kedit、emacs、vi等来编写我们的shell程序。程序必须以下面的行开始（必须方在文件的第一行）：</p>
<p>　　#!/bin/sh</p>
<p>　　符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br>　　当编辑好脚本时，如果要执行该脚本，还必须使其可执行。<br>　　要使脚本可执行：<br>　　chmod +x filename<br>　　然后，您可以通过输入： ./filename<br>来执行您的脚本。</p>
<p>2.脚本基本语法<br>2.1　　注释<br>　　在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。我们真诚地建议您在程序中使用注释。如果您使用了注释，那么即使相当长的时间内没有使用该脚本，您也能在很短的时间内明白该脚本的作用及工作原理。</p>
<p>2.2　　变量<br>　　在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：<br>　　变量名=值<br>　　取出变量值可以加一个美元符号（$）在变量前面：</p>
<p>　　#!/bin/sh</p>
<p>　　#对变量赋值：<br>　　a=”hello world”<br>　　# 现在打印变量a的内容：<br>　　echo “A is:”<br>　　echo $a</p>
<p>　　在您的编辑器中输入以上内容，然后将其保存为一个文件first。之后执行chmod +x first<br>使其可执行，最后输入./first执行该脚本。</p>
<p>　　这个脚本将会输出：<br>　　A is:<br>　　hello world<br>　　有时候变量名很容易与其他文字混淆，比如：<br>　　num=2<br>　　echo “this is the $numnd”<br>　　这并不会打印出”this is the<br>2nd”，而仅仅打印”this is the<br>“，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：<br>　　num=2<br>　　echo “this is the ${num}nd”<br>　　这将打印： this is the 2nd</p>
<p>　　<strong>有许多变量是系统自动设定的，这将在后面使用这些变量时进行讨论。</strong><br>**<span style="line-height: 22px; font-weight: normal;"></span></p>
<p>除了一般的仅在程序内有效的shell变量以外，还有环境变量。由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。**</p>
<p>2.3　　如果您需要处理数学表达式，那么您需要使用诸如expr等程序（见下面）。</p>
<p>3. Shell命令和流程控制<br>3.1　　在shell脚本中可以使用三类命令：<br>3.1.1　Unix 命令:<br>　　虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。<br>　　常用命令语法及功能<br>　　echo “some text”:<br>将文字内容打印在屏幕上<br>　　ls: 文件列表<br>　　wc -l filewc -w filewc -c<br>file&amp;: 计算文件行数计算文件中的单词数计算文件中的字符数<br>　　cp sourcefile<br>destfile&amp;: 文件拷贝<br>　　mv oldname newname :<br>重命名文件或移动文件<br>　　rm file&amp;:<br>删除文件<br>　　grep pattern<br>file&amp;: 在文件内搜索字符串比如：grep searchstring file.txt<br>　　cut -b colnum<br>file&amp;:<br>指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9<br>file.txt千万不要和cat命令混淆，这是两个完全不同的命令<br>　　cat file.txt:<br>输出文件内容到标准输出设备（屏幕）上<br>　　file somefile&amp;:<br>得到文件类型<br>　　read var: 提示用户输入，并将输入赋值给变量<br>　　sort file.txt:<br>对file.txt文件中的行进行排序<br>　　uniq: 删除文本文件中出现的行列比如： sort<br>file.txt | uniq<br>　　expr: 进行数学运算Example: add 2 and<br>3expr 2 “+” 3<br>　　find: 搜索文件比如：根据文件名搜索find . -name<br>filename -print<br>　　tee: 将数据输出到标准输出设备(屏幕)<br>和文件比如：somecommand | tee outfile<br>　　basename file&amp;:<br>返回不包含路径的文件名比如： basename /bin/tux将返回 tux<br>　　dirname file&amp;:<br>返回文件所在路径比如：dirname /bin/tux将返回 /bin<br>　　head file&amp;:<br>打印文本文件开头几行<br>　　tail file : 打印文本文件末尾几行<br>　　sed:<br>Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus<br>替换为 LinuxFocus ： cat text.file | sed s/linuxfocus/LinuxFocus/<br>&gt; newtext.file<br>　　awk: awk<br>用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt | awk<br>-F,{print $1 “,” $3 }这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam<br>Bor,34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry<br>Miller, USA</p>
<p>3.1.2　　 概念: 管道, 重定向和 backtick</p>
<p>　这些不是系统命令，但是他们真的很重要。<br>　管道 (|) 将一个命令的输出作为另外一个命令的输入。<br>　grep “hello” file.txt | wc -l<br>　在file.txt中搜索包含有”hello”的行并计算其行数。<br>　在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。<br>　重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。<br>　&gt; 写入文件并覆盖旧文件<br>　&gt;&gt; 加到文件的尾部，保留旧文件内容。<br>　反短斜线<br>　使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br>　命令：<br>　find . -mtime -1 -type f -print<br>　用来查找过去24小时（-mtime<br>-2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本：</p>
<p>　#!/bin/sh<br>　# The ticks are backticks (<code>) not normal quotes ():
tar -zcvf lastmod.tar.gz</code>find . -mtime -1 -type f -print`</p>
<p>3.2　　流程控制</p>
<p><strong>3.2.1　　“if”<br>表达式如果条件为真则执行then后面的部分：</strong><br>　if ….; then<br>　….<br>　elif ….; then<br>　….<br>　else<br>　….<br>　fi</p>
<p>大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…<br>　通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。<br>　[ -f “somefile” ] ：判断是否是一个文件<br>　[ -x “/bin/ls” ] ：判断/bin/ls是否存在并有可执行权限<br>　[ -n “$var” ] ：判断$var变量是否有值<br>　[ “$a” = “$b” ] ：判断$a和$b是否相等<br>　执行man test可以查看所有测试表达式可以比较和判断的类型。<br>　直接执行以下脚本：</p>
<p>　　#!/bin/sh</p>
<p>　if [ “$SHELL” = “/bin/bash” ]; then<br>　echo “your login shell is the bash (bourne again shell)”<br>　else<br>　echo “your login shell is not bash but $SHELL”<br>　fi</p>
<p>　　变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。</p>
<p>　快捷操作符<br>　熟悉C语言的朋友可能会很喜欢下面的表达式：</p>
<p>　[ -f “/etc/shadow” ] &amp;&amp; echo<br>“This computer uses shadow passwors”</p>
<p>　这里 &amp;&amp;<br>就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果<br>/etc/shadow文件存在则打印” This computer uses shadow<br>passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：</p>
<p>　　#!/bin/sh</p>
<p>　mailfolder=/var/spool/mail/james<br>　[ -r “$mailfolder” ] { echo “Can not read $mailfolder”exit 1;<br>}<br>　echo “$mailfolder has mail from:”<br>　grep “^From “ $mailfolder</p>
<p>　　该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From”<br>一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：</p>
<p>　-打印错误信息<br>　-退出程序</p>
<p>　　我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。</p>
<p>　不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。<br><strong>3.1.2　　case表达式可以用来匹配一个给定的字符串，而不是数字。</strong></p>
<blockquote>
<p>case … in</p>
<p>…) do something here</p>
<p>esac<br>　让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：<br>　file lf.gz<br>　这将返回：<br>　lf.gz: gzip compressed data, deflated, original filename,<br>　last modified: Mon Aug 27 23:09:18 2001, os: Unix<br>　我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：</p>
</blockquote>
<p>　#!/bin/sh<br>　ftype=<code>file &quot;$1&quot;</code><br>　case “$ftype” in<br>　“$1: Zip archive”<em>)<br>　unzip “$1”<br>　“$1: gzip compressed”</em>)<br>　gunzip “$1”<br>　“$1: bzip2 compressed”<em>)<br>　bunzip2 “$1”
　</em>) error “File $1 can not be uncompressed with smartzip”;;<br>　esac</p>
<p>　　您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：</p>
<p>　smartzip articles.zip<br>　$1 就是字符串 articles.zip</p>
<p><strong>3.1.3　　select<br>表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。</strong><br>　select var in …do<br>　break<br>　done<br>　…. now $var can be used ….<br>　下面是一个例子：</p>
<p>　　#!/bin/sh</p>
<p>　echo “What is your favourite OS?”<br>　select var in “Linux” “Gnu Hurd” “Free BSD” “Other”; do<br>　break<br>　done<br>　echo “You have selected $var”</p>
<p>　　下面是该脚本运行的结果：</p>
<p>　What is your favourite OS?<br>　1) Linux<br>　2) Gnu Hurd<br>　3) Free BSD<br>　4) Other<br>　#? 1<br>　You have selected Linux</p>
<p><strong>3.1.4　　您也可以在shell中使用如下的loop表达式：</strong></p>
<p>　while …; do<br>　….<br>　done<br>　while -loop 将运行直到表达式测试为真。 will run while the expression that we<br>test for is true. 关键字”break”<br>用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。<br>　for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：<br>　for var in ….; do<br>　….<br>　done</p>
<p>　　在下面的例子中，将分别打印ABC到屏幕上：</p>
<p>　#!/bin/sh<br>　for var in A B Cdo<br>　echo “var is $var”<br>　done</p>
<p>　　下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：</p>
<p>　　#!/bin/sh</p>
<p>　# list a content summary of a number of RPM packages<br>　# USAGE: showrpm rpmfile1 rpmfile2 …<br>　# EXAMPLE: showrpm /cdrom/RedHat/RPMS/<em>.rpm<br>　for rpmpackage in $</em>; do<br>　if [ -r “$rpmpackage” ];then<br>　echo “=============== $rpmpackage ==============”<br>　rpm -qi -p $rpmpackage<br>　else<br>　echo “ERROR: cannot read file $rpmpackage”<br>　fi<br>　done<br>　这里出现了第二个特殊的变量$*，该变量包含了所有输入的命令行参数值。如果您运行 showrpm openssh.rpm<br>w3m.rpm webgrep.rpm</p>
<p>　　此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.</p>
<p>　　引号</p>
<p>　在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符（比如*）替换成合适的文件名，它变量替换成变量值。为了防止程序作这种替换，您可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件，<br>mail.jpg 和tux.jpg。</p>
<p>　#!/bin/sh<br>　echo *.jpg</p>
<p>　　这将打印出”mail.jpg tux.jpg”的结果。</p>
<p>　引号 (单引号和双引号) 将防止这种通配符扩展：<br>　#!/bin/sh<br>　echo “<em>.jpg”<br>　echo ‘</em>.jpg’<br>　这将打印”*.jpg” 两次。<br>　单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。<br>　#!/bin/sh<br>　echo $SHELL<br>　echo “$SHELL”<br>　echo ‘$SHELL’<br>运行结果为：</p>
<p>　　/bin/bash</p>
<p>　/bin/bash<br>　$SHELL</p>
<p>　　最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：</p>
<p>　　echo *.jpg</p>
<p>　echo $SHELL<br>　这将输出：<br>　*.jpg<br>　$SHELL<br>　Here document.<br>　当要将几行文字传递给一个命令时，here<br>document.（译者注：目前还没有见到过对该词适合的翻译）一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个here<br>document.就不必用echo函数一行行输出。一个 “Here document.quot; 以<br>&lt;&lt; 开头，后面接上一个字符串，这个字符串还必须出现在here<br>document.末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且使用here<br>document.打印帮助：</p>
<p>　　#!/bin/sh</p>
<p>　# we have less than 3 arguments. Print the help text:<br>　if [ $# -lt 3 ]then<br>　cat &lt;&lt;HELP<br>　ren — renames a number of files using sed regular<br>expressions<br>　USAGE: ren regexp replacement files…<br>　EXAMPLE: rename all <em>.HTM files in </em>.html:<br>　ren HTM$ html <em>.HTM<br>　HELP<br>　exit 0<br>　fi<br>　OLD=”$1”<br>　NEW=”$2”<br>　# The shift command removes one argument from the list of<br>　# command line arguments.<br>　shift<br>　shift<br>　# $</em> contains now all the files:<br>　for file in $*; do<br>　if [ -f “$file” ]then<br>　newfile=<code>echo &quot;$file&quot; | sed &quot;s/${OLD}/${NEW}/g&quot;</code><br>　if [ -f “$newfile” ]; then<br>　echo “ERROR: $newfile exists already”<br>　else<br>　echo “renaming $file to $newfile …”<br>　mv “$file” “$newfile”<br>　fi<br>　fi<br>　done</p>
<p>　　这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是否小于3个 (特殊变量$# 表示包含参数的个数)<br>。如果输入参数小于3个，则将帮助文字传递给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。如果输入参数等于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我们使用shift命令将第一个和第二个参数从参数列表中删除，这样原来的第三个参数就成为参数列表$*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。接着我们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目的：得到了旧文件名和新文件名。然后使用mv命令进行重命名。</p>
<p>　　函数</p>
<p>　如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：</p>
<p>　　functionname()</p>
<p>　{<br>　　　# inside the body $1 is the first argument given to the<br>function<br>　　　# $2 the second …<br>　　　body<br>　}</p>
<p>　　您需要在每个程序的开始对函数进行声明。</p>
<p>　下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。<br>　#!/bin/sh<br>　# vim: set sw=4 ts=4 et:<br>　help()<br>　{<br>　　　cat &lt;&lt;HELP<br>　　　xtitlebar — change the name of an xterm, gnome-terminal or kde<br>konsole<br>　　　USAGE: xtitlebar [-h] “string_for_titelbar”<br>　　　OPTIONS: -h help text<br>　　　EXAMPLE: xtitlebar “cvs”<br>　　　HELP<br>　　　exit 0<br>　}<br>　# in case of error or if -h is given we call the function<br>help:<br>　[ -z “$1” ] &amp;&amp; help<br>　[ “$1” = “-h” ] &amp;&amp; help<br>　# send the escape sequence to change the xterm titelbar:<br>　echo -e “33]0;$107”<br>　#在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。<br>　命令行参数<br>　我们已经见过$* 和 $1, $2 … $9<br>等特殊变量，这些特殊变量包含了用户从命令行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的参数和查看帮助的-h选项）。但是在编写更复杂的程序时，您可能会发现您需要更多的自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值<br>(比如文件名)。</p>
<p>有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。</p>
<p>　#!/bin/sh<br>　help()<br>　{<br>　　　cat &lt;&lt;HELP<br>　　　This is a generic command line parser demo.<br>　　　USAGE EXAMPLE: cmdparser -l hello -f — -somefile1<br>somefile2<br>　　　HELP<br>　　　exit 0<br>　}<br>　while [ -n “$1” ]; do<br>　case $1 in<br>　-h) help;shift 1;; # function help is called<br>　-f) opt_f=1;shift 1;; # variable opt_f is set<br>　-l) opt_l=$2;shift 2;; # -l takes an argument -&gt;<br>shift by 2<br>　—) shift;break;; # end of options<br>　-<em>) echo “error: no such option $1. -h for help”;exit 1;;
　</em>) break;;<br>　esac<br>　done<br>　echo “opt_f is $opt_f”<br>　echo “opt_l is $opt_l”<br>　echo “first arg is $1”<br>　echo “2nd arg is $2”</p>
<p>　您可以这样运行该脚本：<br>　cmdparser -l hello -f — -somefile1 somefile2<br>　返回的结果是：<br>　opt_f is 1<br>　opt_l is hello<br>　first arg is -somefile1<br>　2nd arg is somefile2<br>　这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，首先输入的应该是包含减号的参数。</p>
<p>　　实例</p>
<p>　一般编程步骤<br>　现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本（framework.sh），该脚本包含了大多数脚本都需要的框架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令：<br>　cp framework.sh myscript<br>　然后再插入自己的函数。<br>　让我们再看两个例子：<br>　二进制到十进制的转换<br>　脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：</p>
<h1 id="!/bin/sh">!/bin/sh</h1>
<h1 id="vim:_set_sw=4_ts=4_et:">vim: set sw=4 ts=4 et:</h1>
<p>help()<br>{</p>
<p>cat<br>&lt;&lt;HELP</p>
<p>b2h — convert binary to decimal</p>
<p>USAGE: b2h [-h] binarynum</p>
<p>OPTIONS: -h help text</p>
<p>EXAMPLE: b2h 111010</p>
<p>will return 58</p>
<p>HELP</p>
<p>exit 0<br>}</p>
<p>error()<br>{</p>
<h1 id="print_an_error_and_exit">print an error and exit</h1>
<p>echo “$1”</p>
<p>exit 1<br>}</p>
<p>lastchar()<br>{</p>
<h1 id="return_the_last_character_of_a_string">return the last character of a string</h1>
<p>in $rval</p>
<p>if [ -z “$1” ]; then</p>
<h1 id="empty_string">empty string</h1>
<p>rval=””</p>
<p>return</p>
<p>fi</p>
<h1 id="wc_puts_some_space_behind_the_output_this_is">wc puts some space behind the output this is</h1>
<p>why we need sed:</p>
<p>numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed s/ //g</code></p>
<h1 id="now_cut_out_the_last_char">now cut out the last char</h1>
<p>rval=<code>echo -n &quot;$1&quot; | cut -b
$numofchar</code><br>}</p>
<p>chop()<br>{</p>
<h1 id="remove_the_last_character_in_string">remove the last character in string</h1>
<p>and return it in $rval</p>
<p>if [ -z “$1” ]; then</p>
<h1 id="empty_string-1">empty string</h1>
<p>rval=””</p>
<p>return</p>
<p>fi</p>
<h1 id="wc_puts_some_space_behind_the_output_this_is-1">wc puts some space behind the output this is</h1>
<p>why we need sed:</p>
<p>numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed s/ //g</code></p>
<p>if [ “$numofchar” = “1” ]; then</p>
<h1 id="only_one_char_in_string">only one char in string</h1>
<p>rval=””</p>
<p>return</p>
<p>fi</p>
<p>numofcharminus1=<code>expr $numofchar &quot;-&quot;
1</code></p>
<h1 id="now_cut_all_but_the_last_char:">now cut all but the last char:</h1>
<p>rval=<code>echo -n &quot;$1&quot; | cut -b
0-${numofcharminus1}</code><br>}</p>
<p>while [ -n “$1” ]; do<br>　　case $1 in<br>　　-h) help;shift 1;; # function help is<br>called<br>　　—) shift;break;; # end of<br>options<br>　　-<em>) error “error: no such option $1.<br>-h for help”;;
　　</em>) break;;<br>　　esac<br>done</p>
<h1 id="The_main_program">The main program</h1>
<p>　　sum=0<br>　　weight=1<br>　　# one arg must be given:<br>[ -z “$1” ]<br>&amp;&amp; help<br>　　binnum=”$1”<br>　　binnumorig=”$1”</p>
<p>while [ -n “$binnum” ]; do<br>　　lastchar “$binnum”<br>　　if [ “$rval” = “1” ];<br>then<br>　　　　sum=<code>expr &quot;$weight&quot; &quot;+&quot;
&quot;$sum&quot;</code><br>　　fi<br>　　# remove the last position in<br>$binnum<br>　　chop “$binnum”<br>　　binnum=”$rval”<br>　　weight=<code>expr &quot;$weight&quot; &quot;*&quot;
2</code><br>done<br>echo “binary<br>$binnumorig is decimal $sum”</p>
<p>该脚本使用的算法是利用十进制和二进制数权值<br>(1,2,4,8,16,..)，比如二进制”10”可以这样转换成十进制：</p>
<div style="line-height: 22px;" align="left">

<p>　　0 <em> 1 + 1 </em> 2 = 2</p>
<p>　　为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc<br>-c计算字符个数，然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。</p>
<p>　　文件循环程序</p>
<p>　　或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的脚本rotatefile<br>可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，而对于outmail.1就变成了outmail.2<br>等等等等…</p>
<h1 id="!/bin/sh-1">!/bin/sh</h1>
<h1 id="vim:_set_sw=4_ts=4_et:-1">vim: set sw=4 ts=4 et:</h1>
<p>ver=”0.1”<br>help()<br>{</p>
<p>cat<br>&lt;&lt;HELP</p>
<p>rotatefile — rotate the file name</p>
<p>USAGE: rotatefile [-h] filename</p>
<p>OPTIONS: -h help text</p>
<p>EXAMPLE: rotatefile out</p>
<p>This will e.g rename out.2 to out.3, out.1 to<br>out.2, out to out.1</p>
<p>and create an empty out-file</p>
<p>The max number is 10</p>
<p>version $ver</p>
<p>HELP</p>
<p>exit 0<br>}</p>
<p>error()<br>{</p>
<p>echo “$1”</p>
<p>exit 1<br>}</p>
<p>while [ -n “$1” ]; do<br>　　case $1 in<br>　　-h) help;shift 1;;<br>　　—) break;;<br>　　-<em>) echo “error: no such option $1. -h<br>for help”;exit 1;;
　　</em>) break;;<br>　　esac<br>done</p>
<h1 id="input_check:">input check:</h1>
<p>if [ -z “$1” ]then</p>
<p>error “ERROR: you must specify a file, use -h for<br>help”<br>fi</p>
<p>filen=”$1”</p>
<h1 id="rename_any_-1_,_-2_etc">rename any .1 , .2 etc</h1>
<p>file&amp;:</p>
<p>for n in 9 8 7 6 5 4 3 2 1;<br>do<br>　　if [ -f “$filen.$n” ];<br>then</p>
<p>　　p=<code>expr $n + 1</code><br>　　<br>echo “mv $filen.$n $filen.$p”<br>　　<br>mv $filen.$n $filen.$p<br>　　fi<br>done</p>
<h1 id="rename_the_original">rename the original</h1>
<p>file&amp;:<br>if [ -f “$filen” ]; then</p>
<p>echo “mv $filen $filen.1”<br>　mv $filen $filen.1<br>fi<br>echo touch $filen<br>touch $filen</p>
<p>这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名为文件1同时建立一个与原始文件同名的空文件。</p>
<div style="line-height: 22px;" align="left">

<p>　　调试</p>
<p>　　最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。</p>
<p>　　shell也有一个真实的调试模式。如果在脚本”strangescript” 中有错误，您可以这样来进行调试：</p>
<p>　　sh -x strangescript</p>
<p>　　这将执行该脚本并显示所有变量的值。</p>
<p>　　shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用：</p>
<p>　　sh -n your_script<br>这将返回所有语法错误。</p>
</div></div>]]></content>
        <pubTime>2014-03-29T08:36:43.000Z</pubTime>
        
         
              <breadCrumb title="linux" url="http://www.shenjixiang.cn/tags/linux/"/>
          
              <breadCrumb title="linux" url="http://www.shenjixiang.cn/categories/linux/"/>
          
        </display>
    </data>
    </url>

</urlset>
